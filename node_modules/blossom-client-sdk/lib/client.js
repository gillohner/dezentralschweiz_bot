import { getBlobSha256 } from "./helpers/blob.js";
import { createDeleteAuth, createDownloadAuth, createListAuth, createMirrorAuth, createUploadAuth, encodeAuthorizationHeader, } from "./auth.js";
import { mirrorBlob } from "./actions/mirror.js";
import { uploadBlob } from "./actions/upload.js";
import { listBlobs } from "./actions/list.js";
import { downloadBlob } from "./actions/download.js";
import { deleteBlob } from "./actions/delete.js";
import { uploadMedia } from "./actions/media.js";
export class BlossomClient {
    server;
    signer;
    payment;
    constructor(server, signer) {
        this.server = new URL("/", server);
        this.signer = signer;
    }
    // moved to helpers.ts
    static getFileSha256 = getBlobSha256;
    // static auth methods moved to auth.ts
    static createGetAuth = createDownloadAuth;
    static createUploadAuth = createUploadAuth;
    static createListAuth = createListAuth;
    static createDeleteAuth = createDeleteAuth;
    // util
    static encodeAuthorizationHeader = encodeAuthorizationHeader;
    // static blob methods moved to actions
    static mirrorBlob = mirrorBlob;
    static uploadBlob = uploadBlob;
    static listBlobs = listBlobs;
    static downloadBlob = downloadBlob;
    static deleteBlob = deleteBlob;
    static uploadMedia = uploadMedia;
    // download blob
    async createDownloadAuth(hash, options) {
        if (!this.signer)
            throw new Error("Missing signer");
        return await createDownloadAuth(this.signer, hash, options);
    }
    async downloadBlob(hash, opts) {
        const options = { signal: opts?.signal };
        // attach auth
        if (opts?.auth !== false) {
            if (this.signer)
                options.onAuth = (_server, sha256) => this.createDownloadAuth(sha256, { message: `Download ${sha256}` });
            if (typeof opts?.auth === "object")
                options.auth = opts.auth;
        }
        // attach payment
        if (opts?.payment !== false && this.payment)
            options.onPayment = this.payment.download;
        const download = await downloadBlob(this.server, hash, options);
        return download.blob();
    }
    // upload blob
    async createUploadAuth(blob, options) {
        if (!this.signer)
            throw new Error("Missing signer");
        return await createUploadAuth(this.signer, blob, options);
    }
    async uploadBlob(blob, opts) {
        const options = { signal: opts?.signal };
        // attach auth
        if (opts?.auth !== false) {
            if (this.signer)
                options.onAuth = (_server, sha256, type) => this.createUploadAuth(sha256, { type });
            if (typeof opts?.auth === "object")
                options.auth = opts.auth;
        }
        // attach payment
        if (opts?.payment !== false && this.payment)
            options.onPayment = this.payment.upload;
        return uploadBlob(this.server, blob, options);
    }
    // mirror blob
    async createMirrorAuth(blob, options) {
        if (!this.signer)
            throw new Error("Missing signer");
        return await createMirrorAuth(this.signer, typeof blob === "string" ? blob : blob.sha256, options);
    }
    async mirrorBlob(blob, opts) {
        const options = { signal: opts?.signal };
        // attach auth
        if (opts?.auth !== false) {
            if (this.signer)
                options.onAuth = (_server, sha256) => this.createMirrorAuth(sha256);
            if (typeof opts?.auth === "object")
                options.auth = opts.auth;
        }
        // attach payment
        if (opts?.payment !== false && this.payment)
            options.onPayment = this.payment.mirror;
        return mirrorBlob(this.server, blob, options);
    }
    // upload media
    async createMediaAuth(blob, options) {
        return await this.createUploadAuth(blob, { ...options, type: "media" });
    }
    async uploadMedia(blob, opts) {
        const options = { signal: opts?.signal };
        // attach auth
        if (opts?.auth !== false) {
            if (this.signer)
                options.onAuth = (_server, sha256, type) => this.createUploadAuth(sha256, { type });
            if (typeof opts?.auth === "object")
                options.auth = opts.auth;
        }
        // attach payment
        if (opts?.payment !== false && this.payment)
            options.onPayment = this.payment.upload;
        return uploadMedia(this.server, blob, options);
    }
    // has blob
    static async hasBlob(server, hash) {
        const res = await fetch(new URL(`/` + hash, server), { method: "HEAD" });
        return res.status !== 404;
    }
    async hasBlob(hash) {
        return BlossomClient.hasBlob(this.server, hash);
    }
    // list blobs
    async createListAuth(options) {
        if (!this.signer)
            throw new Error("Missing signer");
        return await createListAuth(this.signer, options);
    }
    async listBlobs(pubkey, opts) {
        const options = { signal: opts?.signal };
        // attach auth
        if (opts?.auth !== false) {
            if (this.signer)
                options.onAuth = (_server) => this.createListAuth();
            if (typeof opts?.auth === "object")
                options.auth = opts.auth;
        }
        // attach payment
        if (opts?.payment !== false && this.payment)
            options.onPayment = this.payment.list;
        return listBlobs(this.server, pubkey, options);
    }
    // delete blob
    async createDeleteAuth(blob, options) {
        if (!this.signer)
            throw new Error("Missing signer");
        return await createDeleteAuth(this.signer, blob, options);
    }
    async deleteBlob(hash, opts) {
        const options = { signal: opts?.signal };
        // attach auth
        if (opts?.auth !== false) {
            if (this.signer)
                options.onAuth = (_server, sha256) => this.createDeleteAuth(sha256);
            if (typeof opts?.auth === "object")
                options.auth = opts.auth;
        }
        // attach payment
        if (opts?.payment !== false && this.payment)
            options.onPayment = this.payment.delete;
        return BlossomClient.deleteBlob(this.server, hash, options);
    }
}
