import { AUTH_EVENT_KIND } from "./const.js";
import { getBlobSha256, isSha256 } from "./helpers/blob.js";
import { areServersEqual } from "./helpers/url.js";
export const now = () => Math.floor(new Date().valueOf() / 1000);
export const oneHour = () => now() + 60 * 60;
/** Encodes an auth event into a nostr authorization header */
export function encodeAuthorizationHeader(event) {
    return "Nostr " + btoa(JSON.stringify(event));
}
/** Checks if an auth event matches a server / blob upload */
export async function doseAuthMatchBlob(auth, server, blob, type = "upload") {
    const authType = auth.tags.find((t) => t[0] === "t")?.[1];
    if (authType !== type)
        return false;
    const sha256 = typeof blob === "string" ? blob : await getBlobSha256(blob);
    for (const tag of auth.tags) {
        switch (tag[0]) {
            case "x":
                if (tag[1] === sha256)
                    return true;
                break;
            case "server":
                if (areServersEqual(tag[1], server))
                    return true;
                break;
        }
    }
    return false;
}
/** @deprecated Use `doseAuthMatchBlob` instead */
export const doseAuthMatchUpload = doseAuthMatchBlob;
async function normalizeToHash(blob) {
    return typeof blob === "string" ? blob : getBlobSha256(blob);
}
/** Generic auth event builder */
export async function createAuthEvent(signer, type, options) {
    const draft = {
        created_at: now(),
        kind: AUTH_EVENT_KIND,
        content: options?.message ?? "",
        tags: [
            ["t", type],
            // attach NIP-40 expiration
            ["expiration", String(options?.expiration ?? oneHour())],
        ],
    };
    // add blob tags
    if (options?.blobs) {
        if (Array.isArray(options.blobs)) {
            const seen = new Set();
            for (const blob of options.blobs) {
                const hash = await normalizeToHash(blob);
                if (!seen.has(hash)) {
                    draft.tags.push(["x", hash]);
                    seen.add(hash);
                }
            }
        }
        else
            draft.tags.push(["x", await normalizeToHash(options.blobs)]);
    }
    // add server tags
    if (options?.servers) {
        if (Array.isArray(options.servers))
            for (const server of new Set(options.servers))
                draft.tags.push(["server", server]);
        else
            draft.tags.push(["server", options.servers]);
    }
    return await signer(draft);
}
/** Creates a GET auth event */
export async function createDownloadAuth(signer, serverOrHash, options) {
    if (!Array.isArray(serverOrHash))
        serverOrHash = [serverOrHash];
    return await createAuthEvent(signer, "get", {
        message: "Download Blob",
        ...options,
        blobs: serverOrHash.filter((s) => (typeof s === "string" ? isSha256(s) : true)),
        servers: serverOrHash.filter((s) => typeof s === "string" && !isSha256(s) && URL.canParse(s)),
    });
}
/** Creates an upload or media upload auth event */
export async function createUploadAuth(signer, blobs, options) {
    return await createAuthEvent(signer, options?.type ?? "upload", { message: "Upload Blob", ...options, blobs });
}
/** Creates an upload or media upload auth event */
export async function createMirrorAuth(signer, blobs, options) {
    // The /mirror endpoint uses "upload" type
    return await createAuthEvent(signer, "upload", { message: "Mirror Blob", ...options, blobs });
}
/** Creates a list auth event */
export async function createListAuth(signer, options) {
    return await createAuthEvent(signer, "list", { message: "List Blobs", ...options });
}
/** Creates a "delete" auth event for a specific hash */
export async function createDeleteAuth(signer, blobs, options) {
    return await createAuthEvent(signer, "delete", { message: "Delete Blob", ...options, blobs });
}
