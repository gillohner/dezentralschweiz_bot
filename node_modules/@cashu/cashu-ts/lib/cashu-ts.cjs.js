"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const M=require("@noble/curves/secp256k1"),R=require("@noble/hashes/sha256"),w=require("@noble/curves/abstract/utils"),x=require("buffer"),I=require("@noble/hashes/utils"),Rt=require("@scure/bip32");function W(s){return wt(w.bytesToHex(s))}function wt(s){return BigInt(`0x${s}`)}function Ft(s){return x.Buffer.from(s,"base64")}const Qt=w.hexToBytes("536563703235366b315f48617368546f43757276655f43617368755f");function j(s){const t=R.sha256(x.Buffer.concat([Qt,s])),e=new Uint32Array(1),n=2**16;for(let r=0;r<n;r++){const o=new Uint8Array(e.buffer),c=R.sha256(x.Buffer.concat([t,o]));try{return U(w.bytesToHex(x.Buffer.concat([new Uint8Array([2]),c])))}catch{e[0]++}}throw new Error("No valid point found")}function Ht(s){const e=s.map(r=>r.toHex(!1)).join("");return R.sha256(new TextEncoder().encode(e))}function U(s){return M.secp256k1.ProjectivePoint.fromHex(s)}const Lt=s=>{let t;return/^[a-fA-F0-9]+$/.test(s)?t=wt(s)%BigInt(2**31-1):t=W(Ft(s))%BigInt(2**31-1),t};function Wt(s,t){if(s.length!==t.length)return!1;for(let e=0;e<s.length;e++)if(s[e]!==t[e])return!1;return!0}const Ct=(s,t,e,n)=>{const r=M.secp256k1.ProjectivePoint.fromPrivateKey(w.bytesToHex(s.s)),o=n.multiply(W(s.e)),c=t.multiply(W(s.s)),i=e.multiply(W(s.e)),a=r.subtract(o),u=c.subtract(i),d=Ht([a,u,n,e]);return Wt(d,s.e)},jt=(s,t,e,n)=>{if(t.r===void 0)throw new Error("verifyDLEQProof_reblind: Undefined blinding factor");const r=j(s),o=e.add(n.multiply(t.r)),c=M.secp256k1.ProjectivePoint.fromPrivateKey(t.r),i=r.add(c);return Ct(t,i,o,n)};function $t(s){return x.Buffer.from(s).toString("base64").replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}function kt(s){return x.Buffer.from(s,"base64")}function bt(s){const t=JSON.stringify(s);return Vt(x.Buffer.from(t).toString("base64"))}function zt(s){const t=x.Buffer.from(Gt(s),"base64").toString();return JSON.parse(t)}function Gt(s){return s.replace(/-/g,"+").replace(/_/g,"/").split("=")[0]}function Vt(s){return s.replace(/\+/g,"-").replace(/\//g,"_").split("=")[0]}function Jt(s){return typeof s=="number"||typeof s=="string"}function nt(s){const t=[];return rt(s,t),new Uint8Array(t)}function rt(s,t){if(s===null)t.push(246);else if(s===void 0)t.push(247);else if(typeof s=="boolean")t.push(s?245:244);else if(typeof s=="number")_t(s,t);else if(typeof s=="string")Et(s,t);else if(Array.isArray(s))Xt(s,t);else if(s instanceof Uint8Array)Yt(s,t);else if(typeof s=="object")Zt(s,t);else throw new Error("Unsupported type")}function _t(s,t){if(s<24)t.push(s);else if(s<256)t.push(24,s);else if(s<65536)t.push(25,s>>8,s&255);else if(s<4294967296)t.push(26,s>>24,s>>16&255,s>>8&255,s&255);else throw new Error("Unsupported integer size")}function Yt(s,t){const e=s.length;if(e<24)t.push(64+e);else if(e<256)t.push(88,e);else if(e<65536)t.push(89,e>>8&255,e&255);else if(e<4294967296)t.push(90,e>>24&255,e>>16&255,e>>8&255,e&255);else throw new Error("Byte string too long to encode");for(let n=0;n<s.length;n++)t.push(s[n])}function Et(s,t){const e=new TextEncoder().encode(s),n=e.length;if(n<24)t.push(96+n);else if(n<256)t.push(120,n);else if(n<65536)t.push(121,n>>8&255,n&255);else if(n<4294967296)t.push(122,n>>24&255,n>>16&255,n>>8&255,n&255);else throw new Error("String too long to encode");for(let r=0;r<e.length;r++)t.push(e[r])}function Xt(s,t){const e=s.length;if(e<24)t.push(128|e);else if(e<256)t.push(152,e);else if(e<65536)t.push(153,e>>8,e&255);else throw new Error("Unsupported array length");for(const n of s)rt(n,t)}function Zt(s,t){const e=Object.keys(s);_t(e.length,t),t[t.length-1]|=160;for(const n of e)Et(n,t),rt(s[n],t)}function ot(s){const t=new DataView(s.buffer,s.byteOffset,s.byteLength);return $(t,0).value}function $(s,t){if(t>=s.byteLength)throw new Error("Unexpected end of data");const e=s.getUint8(t++),n=e>>5,r=e&31;switch(n){case 0:return te(s,t,r);case 1:return ee(s,t,r);case 2:return se(s,t,r);case 3:return ne(s,t,r);case 4:return re(s,t,r);case 5:return oe(s,t,r);case 7:return ce(s,t,r);default:throw new Error(`Unsupported major type: ${n}`)}}function H(s,t,e){if(e<24)return{value:e,offset:t};if(e===24)return{value:s.getUint8(t++),offset:t};if(e===25){const n=s.getUint16(t,!1);return t+=2,{value:n,offset:t}}if(e===26){const n=s.getUint32(t,!1);return t+=4,{value:n,offset:t}}if(e===27){const n=s.getUint32(t,!1),r=s.getUint32(t+4,!1);return t+=8,{value:n*2**32+r,offset:t}}throw new Error(`Unsupported length: ${e}`)}function te(s,t,e){const{value:n,offset:r}=H(s,t,e);return{value:n,offset:r}}function ee(s,t,e){const{value:n,offset:r}=H(s,t,e);return{value:-1-n,offset:r}}function se(s,t,e){const{value:n,offset:r}=H(s,t,e);if(r+n>s.byteLength)throw new Error("Byte string length exceeds data length");return{value:new Uint8Array(s.buffer,s.byteOffset+r,n),offset:r+n}}function ne(s,t,e){const{value:n,offset:r}=H(s,t,e);if(r+n>s.byteLength)throw new Error("String length exceeds data length");const o=new Uint8Array(s.buffer,s.byteOffset+r,n);return{value:new TextDecoder().decode(o),offset:r+n}}function re(s,t,e){const{value:n,offset:r}=H(s,t,e),o=[];let c=r;for(let i=0;i<n;i++){const a=$(s,c);o.push(a.value),c=a.offset}return{value:o,offset:c}}function oe(s,t,e){const{value:n,offset:r}=H(s,t,e),o={};let c=r;for(let i=0;i<n;i++){const a=$(s,c);if(!Jt(a.value))throw new Error("Invalid key type");const u=$(s,a.offset);o[a.value]=u.value,c=u.offset}return{value:o,offset:c}}function ie(s){const t=(s&31744)>>10,e=s&1023,n=s&32768?-1:1;return t===0?n*2**-14*(e/1024):t===31?e?NaN:n*(1/0):n*2**(t-15)*(1+e/1024)}function ce(s,t,e){if(e<24)switch(e){case 20:return{value:!1,offset:t};case 21:return{value:!0,offset:t};case 22:return{value:null,offset:t};case 23:return{value:void 0,offset:t};default:throw new Error(`Unknown simple value: ${e}`)}if(e===24)return{value:s.getUint8(t++),offset:t};if(e===25){const n=ie(s.getUint16(t,!1));return t+=2,{value:n,offset:t}}if(e===26){const n=s.getFloat32(t,!1);return t+=4,{value:n,offset:t}}if(e===27){const n=s.getFloat64(t,!1);return t+=8,{value:n,offset:t}}throw new Error(`Unknown simple or float value: ${e}`)}class G{constructor(t,e,n,r,o,c,i=!1,a){this.transport=t,this.id=e,this.amount=n,this.unit=r,this.mints=o,this.description=c,this.singleUse=i,this.nut10=a}toRawRequest(){const t={};return this.transport&&(t.t=this.transport.map(e=>({t:e.type,a:e.target,g:e.tags}))),this.id&&(t.i=this.id),this.amount&&(t.a=this.amount),this.unit&&(t.u=this.unit),this.mints&&(t.m=this.mints),this.description&&(t.d=this.description),this.singleUse&&(t.s=this.singleUse),this.nut10&&(t.nut10={k:this.nut10.kind,d:this.nut10.data,t:this.nut10.tags}),t}toEncodedRequest(){const t=this.toRawRequest(),e=nt(t);return"creqA"+x.Buffer.from(e).toString("base64")}getTransport(t){return this.transport?.find(e=>e.type===t)}static fromRawRequest(t){const e=t.t?t.t.map(r=>({type:r.t,target:r.a,tags:r.g})):void 0,n=t.nut10?{kind:t.nut10.k,data:t.nut10.d,tags:t.nut10.t}:void 0;return new G(e,t.i,t.a,t.u,t.m,t.d,t.s,n)}static fromEncodedRequest(t){if(!t.startsWith("creq"))throw new Error("unsupported pr: invalid prefix");if(t[4]!=="A")throw new Error("unsupported pr version");const n=t.slice(5),r=kt(n),o=ot(r);return this.fromRawRequest(o)}}const ae="A",ue="cashu";function T(s,t,e,n){if(e){const o=pt(e);if(o>s)throw new Error(`Split is greater than total amount: ${o} > ${s}`);if(e.some(c=>!Pt(c,t)))throw new Error("Provided amount preferences do not match the amounts of the mint keyset.");s=s-pt(e)}else e=[];return St(t,"desc").forEach(o=>{const c=Math.floor(s/o);for(let i=0;i<c;++i)e?.push(o);s%=o}),e.sort((o,c)=>o-c)}function ft(s,t,e,n){const r=[],o=s.map(u=>u.amount);St(e,"asc").forEach(u=>{const d=o.filter(p=>p===u).length,f=Math.max(n-d,0);for(let p=0;p<f&&!(r.reduce((h,l)=>h+l,0)+u>t);++p)r.push(u)});const i=t-r.reduce((u,d)=>u+d,0);return i&&T(i,e).forEach(d=>{r.push(d)}),r.sort((u,d)=>u-d)}function St(s,t="desc"){return t=="desc"?Object.keys(s).map(e=>parseInt(e)).sort((e,n)=>n-e):Object.keys(s).map(e=>parseInt(e)).sort((e,n)=>e-n)}function Pt(s,t){return s in t}function he(s){return At(w.bytesToHex(s))}function At(s){return BigInt(`0x${s}`)}function de(s){return s.toString(16).padStart(64,"0")}function yt(s){return/^[a-f0-9]*$/i.test(s)}function Tt(s){return Array.isArray(s)?s.some(t=>!yt(t.id)):yt(s.id)}function le(s){const t={token:[{mint:s.mint,proofs:s.proofs}]};return s.unit&&(t.unit=s.unit),s.memo&&(t.memo=s.memo),ue+ae+bt(t)}function fe(s,t){if(Tt(s.proofs)||t?.version===3){if(t?.version===4)throw new Error("can not encode to v4 token if proofs contain non-hex keyset id");return le(s)}return vt(s)}function vt(s){if(s.proofs.forEach(i=>{if(i.dleq&&i.dleq.r==null)throw new Error("Missing blinding factor in included DLEQ proof")}),Tt(s.proofs))throw new Error("can not encode to v4 token if proofs contain non-hex keyset id");const e=It(s),n=nt(e),r="cashu",o="B",c=$t(n);return r+o+c}function It(s){const t={},e=s.mint;for(let r=0;r<s.proofs.length;r++){const o=s.proofs[r];t[o.id]?t[o.id].push(o):t[o.id]=[o]}const n={m:e,u:s.unit||"sat",t:Object.keys(t).map(r=>({i:w.hexToBytes(r),p:t[r].map(o=>({a:o.amount,s:o.secret,c:w.hexToBytes(o.C),...o.dleq&&{d:{e:w.hexToBytes(o.dleq.e),s:w.hexToBytes(o.dleq.s),r:w.hexToBytes(o.dleq.r??"00")}},...o.witness&&{w:JSON.stringify(o.witness)}}))}))};return s.memo&&(n.d=s.memo),n}function Bt(s){const t=[];s.t.forEach(n=>n.p.forEach(r=>{t.push({secret:r.s,C:w.bytesToHex(r.c),amount:r.a,id:w.bytesToHex(n.i),...r.d&&{dleq:{r:w.bytesToHex(r.d.r),s:w.bytesToHex(r.d.s),e:w.bytesToHex(r.d.e)}},...r.w&&{witness:r.w}})}));const e={mint:s.m,proofs:t,unit:s.u||"sat"};return s.d&&(e.memo=s.d),e}function qt(s){return["web+cashu://","cashu://","cashu:","cashu"].forEach(e=>{s.startsWith(e)&&(s=s.slice(e.length))}),ye(s)}function ye(s){const t=s.slice(0,1),e=s.slice(1);if(t==="A"){const n=zt(e);if(n.token.length>1)throw new Error("Multi entry token are not supported");const r=n.token[0],o={mint:r.mint,proofs:r.proofs,unit:n.unit||"sat"};return n.memo&&(o.memo=n.memo),o}else if(t==="B"){const n=kt(e),r=ot(n);return Bt(r)}throw new Error("Token version is not supported")}function pe(s){const t=Object.entries(s).sort((r,o)=>+r[0]-+o[0]).map(([,r])=>w.hexToBytes(r)).reduce((r,o)=>me(r,o),new Uint8Array),e=R.sha256(t);return"00"+Buffer.from(e).toString("hex").slice(0,14)}function me(s,t){const e=new Uint8Array(s.length+t.length);return e.set(s),e.set(t,s.length),e}function q(s){return typeof s=="object"}function _(...s){return s.map(t=>t.replace(/(^\/+|\/+$)/g,"")).join("/")}function xt(s){return s.replace(/\/$/,"")}function D(s){return s.reduce((t,e)=>t+e.amount,0)}function ge(s){return G.fromEncodedRequest(s)}class we{get value(){return this._value}set value(t){this._value=t}get next(){return this._next}set next(t){this._next=t}constructor(t){this._value=t,this._next=null}}class ke{get first(){return this._first}set first(t){this._first=t}get last(){return this._last}set last(t){this._last=t}get size(){return this._size}set size(t){this._size=t}constructor(){this._first=null,this._last=null,this._size=0}enqueue(t){const e=new we(t);return this._size===0||!this._last?(this._first=e,this._last=e):(this._last.next=e,this._last=e),this._size++,!0}dequeue(){if(this._size===0||!this._first)return null;const t=this._first;return this._first=t.next,t.next=null,this._size--,t.value}}function C(s){return s.map(t=>{const e={...t};return delete e.dleq,e})}function it(s,t){if(s.dleq==null)return!1;const e={e:w.hexToBytes(s.dleq.e),s:w.hexToBytes(s.dleq.s),r:At(s.dleq.r??"00")};if(!Pt(s.amount,t.keys))throw new Error(`undefined key for amount ${s.amount}`);const n=t.keys[s.amount];return!!jt(new TextEncoder().encode(s.secret),e,U(s.C),U(n))}function be(...s){const t=s.reduce((r,o)=>r+o.length,0),e=new Uint8Array(t);let n=0;for(let r=0;r<s.length;r++)e.set(s[r],n),n=n+s[r].length;return e}function _e(s){const t=new TextEncoder,e=It(s),n=nt(e),r=t.encode("craw"),o=t.encode("B");return be(r,o,n)}function Ee(s){const t=new TextDecoder,e=t.decode(s.slice(0,4)),n=t.decode(new Uint8Array([s[4]]));if(e!=="craw"||n!=="B")throw new Error("not a valid binary token");const r=s.slice(5),o=ot(r);return Bt(o)}function pt(s){return s.reduce((t,e)=>t+e,0)}let ct;typeof WebSocket<"u"&&(ct=WebSocket);function Se(s){ct=s}function Pe(){return ct}class N{constructor(){this.connectionMap=new Map}static getInstance(){return N.instace||(N.instace=new N),N.instace}getConnection(t){if(this.connectionMap.has(t))return this.connectionMap.get(t);const e=new Ae(t);return this.connectionMap.set(t,e),e}}class Ae{constructor(t){this.subListeners={},this.rpcListeners={},this.rpcId=0,this._WS=Pe(),this.url=new URL(t),this.messageQueue=new ke}connect(){return this.connectionPromise||(this.connectionPromise=new Promise((t,e)=>{try{this.ws=new this._WS(this.url.toString())}catch(n){e(n);return}this.ws.onopen=()=>{t()},this.ws.onerror=()=>{e(new Error("Failed to open WebSocket"))},this.ws.onmessage=n=>{this.messageQueue.enqueue(n.data),this.handlingInterval||(this.handlingInterval=setInterval(this.handleNextMesage.bind(this),0))},this.ws.onclose=()=>{this.connectionPromise=void 0}})),this.connectionPromise}sendRequest(t,e){if(this.ws?.readyState!==1)throw new Error("Socket not open...");const n=this.rpcId;this.rpcId++;const r=JSON.stringify({jsonrpc:"2.0",method:t,params:e,id:n});this.ws?.send(r)}closeSubscription(t){this.ws?.send(JSON.stringify(["CLOSE",t]))}addSubListener(t,e){(this.subListeners[t]=this.subListeners[t]||[]).push(e)}addRpcListener(t,e,n){this.rpcListeners[n]={callback:t,errorCallback:e}}removeRpcListener(t){delete this.rpcListeners[t]}removeListener(t,e){if(this.subListeners[t]){if(this.subListeners[t].length===1){delete this.subListeners[t];return}this.subListeners[t]=this.subListeners[t].filter(n=>n!==e)}}async ensureConnection(){this.ws?.readyState!==1&&await this.connect()}handleNextMesage(){if(this.messageQueue.size===0){clearInterval(this.handlingInterval),this.handlingInterval=void 0;return}const t=this.messageQueue.dequeue();let e;try{if(e=JSON.parse(t),"result"in e&&e.id!=null)this.rpcListeners[e.id]&&(this.rpcListeners[e.id].callback(),this.removeRpcListener(e.id));else if("error"in e&&e.id!=null)this.rpcListeners[e.id]&&(this.rpcListeners[e.id].errorCallback(e.error),this.removeRpcListener(e.id));else if("method"in e&&!("id"in e)){const n=e.params.subId;if(!n)return;if(this.subListeners[n]?.length>0){const r=e;this.subListeners[n].forEach(o=>o(r.params.payload))}}}catch(n){console.error(n);return}}createSubscription(t,e,n){if(this.ws?.readyState!==1)return n(new Error("Socket is not open"));const r=(Math.random()+1).toString(36).substring(7);return this.addRpcListener(()=>{this.addSubListener(r,e)},o=>{n(new Error(o.message))},this.rpcId),this.sendRequest("subscribe",{...t,subId:r}),this.rpcId++,r}cancelSubscription(t,e){this.removeRpcListener(t),this.removeListener(t,e),this.rpcId++,this.sendRequest("unsubscribe",{subId:t})}get activeSubscriptions(){return Object.keys(this.subListeners)}close(){this.ws&&this.ws?.close()}}const Te={UNSPENT:"UNSPENT",PENDING:"PENDING",SPENT:"SPENT"},F={UNPAID:"UNPAID",PENDING:"PENDING",PAID:"PAID"},z={UNPAID:"UNPAID",PAID:"PAID",ISSUED:"ISSUED"};var Mt=(s=>(s.POST="post",s.NOSTR="nostr",s))(Mt||{});class Q extends Error{constructor(t,e){super(t),this.status=e,this.name="HttpResponseError",Object.setPrototypeOf(this,Q.prototype)}}class V extends Error{constructor(t){super(t),this.name="NetworkError",Object.setPrototypeOf(this,V.prototype)}}class J extends Q{constructor(t,e){super(e||"Unknown mint operation error",400),this.code=t,this.name="MintOperationError",Object.setPrototypeOf(this,J.prototype)}}let Kt={};function ve(s){Kt=s}async function Ie({endpoint:s,requestBody:t,headers:e,...n}){const r=t?JSON.stringify(t):void 0,o={Accept:"application/json, text/plain, */*",...r?{"Content-Type":"application/json"}:void 0,...e};let c;try{c=await fetch(s,{body:r,headers:o,...n})}catch(i){throw new V(i instanceof Error?i.message:"Network request failed")}if(!c.ok){const i=await c.json().catch(()=>({error:"bad response"}));throw c.status===400&&"code"in i&&"detail"in i?new J(i.code,i.detail):new Q("error"in i?i.error:i.detail||"HTTP request failed",c.status)}try{return await c.json()}catch(i){throw console.error("Failed to parse HTTP response",i),new Q("bad response",c.status)}}async function P(s){return await Ie({...s,...Kt})}function Y(s){return s.state||(console.warn("Field 'state' not found in MeltQuoteResponse. Update NUT-05 of mint: https://github.com/cashubtc/nuts/pull/136)"),typeof s.paid=="boolean"&&(s.state=s.paid?F.PAID:F.UNPAID)),s}function mt(s){return s.state||(console.warn("Field 'state' not found in MintQuoteResponse. Update NUT-04 of mint: https://github.com/cashubtc/nuts/pull/141)"),typeof s.paid=="boolean"&&(s.state=s.paid?z.PAID:z.UNPAID)),s}function Be(s){return Array.isArray(s?.contact)&&s?.contact.length>0&&(s.contact=s.contact.map(t=>Array.isArray(t)&&t.length===2&&typeof t[0]=="string"&&typeof t[1]=="string"?(console.warn("Mint returned deprecated 'contact' field: Update NUT-06: https://github.com/cashubtc/nuts/pull/117"),{method:t[0],info:t[1]}):t)),s}class et{constructor(t){this._mintInfo=t,t.nuts[22]&&(this._protectedEnpoints={cache:{},apiReturn:t.nuts[22].protected_endpoints.map(e=>({method:e.method,regex:new RegExp(e.path)}))})}isSupported(t){switch(t){case 4:case 5:return this.checkMintMelt(t);case 7:case 8:case 9:case 10:case 11:case 12:case 14:case 20:return this.checkGenericNut(t);case 17:return this.checkNut17();case 15:return this.checkNut15();default:throw new Error("nut is not supported by cashu-ts")}}requiresBlindAuthToken(t){if(!this._protectedEnpoints)return!1;if(typeof this._protectedEnpoints.cache[t]=="boolean")return this._protectedEnpoints.cache[t];const e=this._protectedEnpoints.apiReturn.some(n=>n.regex.test(t));return this._protectedEnpoints.cache[t]=e,e}checkGenericNut(t){return this._mintInfo.nuts[t]?.supported?{supported:!0}:{supported:!1}}checkMintMelt(t){const e=this._mintInfo.nuts[t];return e&&e.methods.length>0&&!e.disabled?{disabled:!1,params:e.methods}:{disabled:!0,params:e.methods}}checkNut17(){return this._mintInfo.nuts[17]&&this._mintInfo.nuts[17].supported.length>0?{supported:!0,params:this._mintInfo.nuts[17].supported}:{supported:!1}}checkNut15(){return this._mintInfo.nuts[15]&&this._mintInfo.nuts[15].methods.length>0?{supported:!0,params:this._mintInfo.nuts[15].methods}:{supported:!1}}get contact(){return this._mintInfo.contact}get description(){return this._mintInfo.description}get description_long(){return this._mintInfo.description_long}get name(){return this._mintInfo.name}get pubkey(){return this._mintInfo.pubkey}get nuts(){return this._mintInfo.nuts}get version(){return this._mintInfo.version}get motd(){return this._mintInfo.motd}}class S{constructor(t,e,n){this._mintUrl=t,this._customRequest=e,this._checkNut22=!1,this._mintUrl=xt(t),this._customRequest=e,n&&(this._checkNut22=!0,this._authTokenGetter=n)}get mintUrl(){return this._mintUrl}static async getInfo(t,e){const r=await(e||P)({endpoint:_(t,"/v1/info")});return Be(r)}async getInfo(){return S.getInfo(this._mintUrl,this._customRequest)}async getLazyMintInfo(){if(this._mintInfo)return this._mintInfo;const t=await S.getInfo(this._mintUrl,this._customRequest);return this._mintInfo=new et(t),this._mintInfo}static async swap(t,e,n,r){const o=n||P,c=r?{"Blind-auth":r}:{},i=await o({endpoint:_(t,"/v1/swap"),method:"POST",requestBody:e,headers:c});if(!q(i)||!Array.isArray(i?.signatures))throw new Error(i.detail??"bad response");return i}async swap(t){const e=await this.handleBlindAuth("/v1/swap");return S.swap(this._mintUrl,t,this._customRequest,e)}static async createMintQuote(t,e,n,r){const o=n||P,c=r?{"Blind-auth":r}:{},i=await o({endpoint:_(t,"/v1/mint/quote/bolt11"),method:"POST",requestBody:e,headers:c});return mt(i)}async createMintQuote(t){const e=await this.handleBlindAuth("/v1/mint/quote/bolt11");return S.createMintQuote(this._mintUrl,t,this._customRequest,e)}static async checkMintQuote(t,e,n,r){const o=n||P,c=r?{"Blind-auth":r}:{},i=await o({endpoint:_(t,"/v1/mint/quote/bolt11",e),method:"GET",headers:c});return mt(i)}async checkMintQuote(t){const e=await this.handleBlindAuth(`/v1/mint/quote/bolt11/${t}`);return S.checkMintQuote(this._mintUrl,t,this._customRequest,e)}static async mint(t,e,n,r){const o=n||P,c=r?{"Blind-auth":r}:{},i=await o({endpoint:_(t,"/v1/mint/bolt11"),method:"POST",requestBody:e,headers:c});if(!q(i)||!Array.isArray(i?.signatures))throw new Error("bad response");return i}async mint(t){const e=await this.handleBlindAuth("/v1/mint/bolt11");return S.mint(this._mintUrl,t,this._customRequest,e)}static async createMeltQuote(t,e,n,r){const o=n||P,c=r?{"Blind-auth":r}:{},i=await o({endpoint:_(t,"/v1/melt/quote/bolt11"),method:"POST",requestBody:e,headers:c}),a=Y(i);if(!q(a)||typeof a?.amount!="number"||typeof a?.fee_reserve!="number"||typeof a?.quote!="string")throw new Error("bad response");return a}async createMeltQuote(t){const e=await this.handleBlindAuth("/v1/melt/quote/bolt11");return S.createMeltQuote(this._mintUrl,t,this._customRequest,e)}static async checkMeltQuote(t,e,n,r){const o=n||P,c=r?{"Blind-auth":r}:{},i=await o({endpoint:_(t,"/v1/melt/quote/bolt11",e),method:"GET",headers:c}),a=Y(i);if(!q(a)||typeof a?.amount!="number"||typeof a?.fee_reserve!="number"||typeof a?.quote!="string"||typeof a?.state!="string"||!Object.values(F).includes(a.state))throw new Error("bad response");return a}async checkMeltQuote(t){const e=await this.handleBlindAuth(`/v1/melt/quote/bolt11/${t}`);return S.checkMeltQuote(this._mintUrl,t,this._customRequest,e)}static async melt(t,e,n,r){const o=n||P,c=r?{"Blind-auth":r}:{},i=await o({endpoint:_(t,"/v1/melt/bolt11"),method:"POST",requestBody:e,headers:c}),a=Y(i);if(!q(a)||typeof a?.state!="string"||!Object.values(F).includes(a.state))throw new Error("bad response");return a}async melt(t){const e=await this.handleBlindAuth("/v1/melt/bolt11");return S.melt(this._mintUrl,t,this._customRequest,e)}static async check(t,e,n){const o=await(n||P)({endpoint:_(t,"/v1/checkstate"),method:"POST",requestBody:e});if(!q(o)||!Array.isArray(o?.states))throw new Error("bad response");return o}static async getKeys(t,e,n){e&&(e=e.replace(/\//g,"_").replace(/\+/g,"-"));const o=await(n||P)({endpoint:e?_(t,"/v1/keys",e):_(t,"/v1/keys")});if(!q(o)||!Array.isArray(o.keysets))throw new Error("bad response");return o}async getKeys(t,e){return await S.getKeys(e||this._mintUrl,t,this._customRequest)}static async getKeySets(t,e){return(e||P)({endpoint:_(t,"/v1/keysets")})}async getKeySets(){return S.getKeySets(this._mintUrl,this._customRequest)}async check(t){return S.check(this._mintUrl,t,this._customRequest)}static async restore(t,e,n){const o=await(n||P)({endpoint:_(t,"/v1/restore"),method:"POST",requestBody:e});if(!q(o)||!Array.isArray(o?.outputs)||!Array.isArray(o?.signatures))throw new Error("bad response");return o}async restore(t){return S.restore(this._mintUrl,t,this._customRequest)}async connectWebSocket(){if(this.ws)await this.ws.ensureConnection();else{const t=new URL(this._mintUrl),e="v1/ws";t.pathname&&(t.pathname.endsWith("/")?t.pathname+=e:t.pathname+="/"+e),this.ws=N.getInstance().getConnection(`${t.protocol==="https:"?"wss":"ws"}://${t.host}${t.pathname}`);try{await this.ws.connect()}catch(n){throw console.log(n),new Error("Failed to connect to WebSocket...")}}}disconnectWebSocket(){this.ws&&this.ws.close()}get webSocketConnection(){return this.ws}async handleBlindAuth(t){if(!this._checkNut22)return;if((await this.getLazyMintInfo()).requiresBlindAuthToken(t)){if(!this._authTokenGetter)throw new Error("Can not call a protected endpoint without authProofGetter");return this._authTokenGetter()}}}const qe=s=>{try{return s instanceof Uint8Array&&(s=new TextDecoder().decode(s)),JSON.parse(s)}catch{throw new Error("can't parse secret")}},xe=(s,t)=>{const e=R.sha256(new TextDecoder().decode(s));return M.schnorr.sign(e,t)},gt=(s,t)=>{let e=[],n="";if(t instanceof Array)for(const r of t)e.push({priv:r,pub:w.bytesToHex(M.schnorr.getPublicKey(r))});else n=t;return s.map(r=>{try{const o=qe(r.secret);if(o[0]!=="P2PK")throw new Error("unknown secret type");if(e.length){const c=e.find(i=>o[1].data===i.pub)?.priv;if(c)n=c;else throw new Error("no matching key found")}return Me(r,w.hexToBytes(n))}catch{return r}})},Me=(s,t)=>(s.witness||(s.witness={signatures:[w.bytesToHex(xe(s.secret,t))]}),s);function X(s,t,e){const n=j(s);t||(t=W(M.secp256k1.utils.randomPrivateKey()));const r=M.secp256k1.ProjectivePoint.BASE.multiply(t);return{B_:n.add(r),r:t,secret:s}}function Ke(s,t,e){return s.subtract(e.multiply(t))}function De(s,t,e,n){const r=n,o=Ke(s.C_,t,r);return{id:s.id,amount:s.amount,secret:e,C:o}}const st=s=>({amount:s.amount,C:s.C.toHex(!0),id:s.id,secret:new TextDecoder().decode(s.secret),witness:JSON.stringify(s.witness)});function Ue(s,t){let e=s;for(const r of t)e+=r.B_;const n=new TextEncoder().encode(e);return R.sha256(n)}function Ne(s,t,e){const n=Ue(t,e),r=I.hexToBytes(s),o=M.schnorr.sign(n,r);return I.bytesToHex(o)}class Z{constructor(t,e,n){this.amount=t,this.B_=e,this.id=n}getSerializedBlindedMessage(){return{amount:this.amount,B_:this.B_.toHex(!0),id:this.id}}}const Oe="m/129372'/0'",Re=(s,t,e)=>Dt(s,t,e,0),Fe=(s,t,e)=>Dt(s,t,e,1),Dt=(s,t,e,n)=>{const r=Rt.HDKey.fromMasterSeed(s),o=Lt(t),c=`${Oe}/${o}'/${e}'/${n}`,i=r.derive(c);if(i.privateKey===null)throw new Error("Could not derive private key");return i.privateKey};function tt(s){return typeof s=="function"}class B{constructor(t,e,n){this.secret=n,this.blindingFactor=e,this.blindedMessage=t}toProof(t,e){let n;t.dleq&&(n={s:I.hexToBytes(t.dleq.s),e:I.hexToBytes(t.dleq.e),r:this.blindingFactor});const r={id:t.id,amount:t.amount,C_:U(t.C_),dleq:n},o=U(e.keys[t.amount]),c=De(r,this.blindingFactor,this.secret,o);return{...st(c),...n&&{dleq:{s:I.bytesToHex(n.s),e:I.bytesToHex(n.e),r:de(n.r??BigInt(0))}}}}static createP2PKData(t,e,n,r){return T(e,n.keys,r).map(c=>this.createSingleP2PKData(t,c,n.id))}static createSingleP2PKData(t,e,n){const r=["P2PK",{nonce:I.bytesToHex(I.randomBytes(32)),data:t.pubkey,tags:[]}];t.locktime&&r[1].tags.push(["locktime",t.locktime]),t.refundKeys&&r[1].tags.push(["refund",...t.refundKeys]);const o=JSON.stringify(r),c=new TextEncoder().encode(o),{r:i,B_:a}=X(c);return new B(new Z(e,a,n).getSerializedBlindedMessage(),i,c)}static createRandomData(t,e,n){return T(t,e.keys,n).map(o=>this.createSingleRandomData(o,e.id))}static createSingleRandomData(t,e){const n=I.bytesToHex(I.randomBytes(32)),r=new TextEncoder().encode(n),{r:o,B_:c}=X(r);return new B(new Z(t,c,e).getSerializedBlindedMessage(),o,r)}static createDeterministicData(t,e,n,r,o){return T(t,r.keys,o).map((i,a)=>this.createSingleDeterministicData(i,e,n+a,r.id))}static createSingleDeterministicData(t,e,n,r){const o=Re(e,r,n),c=I.bytesToHex(o),i=new TextEncoder().encode(c),a=he(Fe(e,r,n)),{r:u,B_:d}=X(i,a);return new B(new Z(t,d,r).getSerializedBlindedMessage(),u,i)}}const Qe=3,He="sat";class Le{constructor(t,e){this._keys=new Map,this._keysets=[],this._seed=void 0,this._unit=He,this._mintInfo=void 0,this._denominationTarget=Qe,this.mint=t;let n=[];if(e?.keys&&!Array.isArray(e.keys)?n=[e.keys]:e?.keys&&Array.isArray(e?.keys)&&(n=e?.keys),n&&n.forEach(r=>this._keys.set(r.id,r)),e?.unit&&(this._unit=e?.unit),e?.keysets&&(this._keysets=e.keysets),e?.mintInfo&&(this._mintInfo=new et(e.mintInfo)),e?.denominationTarget&&(this._denominationTarget=e.denominationTarget),e?.bip39seed){if(e.bip39seed instanceof Uint8Array){this._seed=e.bip39seed;return}throw new Error("bip39seed must be a valid UInt8Array")}e?.keepFactory&&(this._keepFactory=e.keepFactory)}get unit(){return this._unit}get keys(){return this._keys}get keysetId(){if(!this._keysetId)throw new Error("No keysetId set");return this._keysetId}set keysetId(t){this._keysetId=t}get keysets(){return this._keysets}get mintInfo(){if(!this._mintInfo)throw new Error("Mint info not loaded");return this._mintInfo}async getMintInfo(){const t=await this.mint.getInfo();return this._mintInfo=new et(t),this._mintInfo}async lazyGetMintInfo(){return this._mintInfo?this._mintInfo:await this.getMintInfo()}async loadMint(){await this.getMintInfo(),await this.getKeySets(),await this.getKeys()}getActiveKeyset(t){let e=t.filter(r=>r.active);e=e.filter(r=>r.id.startsWith("00"));const n=e.sort((r,o)=>(r.input_fee_ppk??0)-(o.input_fee_ppk??0))[0];if(!n)throw new Error("No active keyset found");return n}async getKeySets(){const e=(await this.mint.getKeySets()).keysets.filter(n=>n.unit===this._unit);return this._keysets=e,this._keysets}async getAllKeys(){const t=await this.mint.getKeys();return this._keys=new Map(t.keysets.map(e=>[e.id,e])),this.keysetId=this.getActiveKeyset(this._keysets).id,t.keysets}async getKeys(t,e){if((!(this._keysets.length>0)||e)&&await this.getKeySets(),t||(t=this.getActiveKeyset(this._keysets).id),!this._keysets.find(n=>n.id===t)&&(await this.getKeySets(),!this._keysets.find(n=>n.id===t)))throw new Error(`could not initialize keys. No keyset with id '${t}' found`);if(!this._keys.get(t)){const n=await this.mint.getKeys(t);this._keys.set(t,n.keysets[0])}return this.keysetId=t,this._keys.get(t)}async receive(t,e){const{requireDleq:n,keysetId:r,outputAmounts:o,counter:c,pubkey:i,privkey:a,outputData:u,p2pk:d}=e||{};typeof t=="string"&&(t=qt(t));const f=await this.getKeys(r);if(n&&t.proofs.some(b=>!it(b,f)))throw new Error("Token contains proofs with invalid DLEQ");const p=D(t.proofs)-this.getFeesForProofs(t.proofs);let h;u?h={send:u}:this._keepFactory&&(h={send:this._keepFactory});const l=this.createSwapPayload(p,t.proofs,f,o,c,i,a,h,d),{signatures:k}=await this.mint.swap(l.payload),m=l.outputData.map((b,y)=>b.toProof(k[y],f)),g=[];return l.sortedIndices.forEach((b,y)=>{g[b]=m[y]}),g}async send(t,e,n){const{proofsWeHave:r,offline:o,includeFees:c,includeDleq:i,keysetId:a,outputAmounts:u,pubkey:d,privkey:f,outputData:p}=n||{};if(i&&(e=e.filter(m=>m.dleq!=null)),D(e)<t)throw new Error("Not enough funds available to send");const{keep:h,send:l}=this.selectProofsToSend(e,t,n?.includeFees),k=c?this.getFeesForProofs(l):0;if(!o&&(D(l)!=t+k||u||d||f||a||p)){const{keep:m,send:g}=this.selectProofsToSend(e,t,!0);r?.push(...m);const b=await this.swap(t,g,n);let{keep:y,send:A}=b;const K=b.serialized;return y=m.concat(y),i||(A=C(A)),{keep:y,send:A,serialized:K}}if(D(l)<t+k)throw new Error("Not enough funds available to send");return i?{keep:h,send:l}:{keep:h,send:C(l)}}selectProofsToSend(t,e,n){const r=t.sort((h,l)=>h.amount-l.amount),o=r.filter(h=>h.amount<=e).sort((h,l)=>l.amount-h.amount),i=r.filter(h=>h.amount>e).sort((h,l)=>h.amount-l.amount)[0];if(!o.length&&i)return{keep:t.filter(h=>h.secret!==i.secret),send:[i]};if(!o.length&&!i)return{keep:t,send:[]};let a=e,u=[o[0]];const d=[],f=n?this.getFeesForProofs(u):0;if(a-=u[0].amount-f/1e3,a>0){const{keep:h,send:l}=this.selectProofsToSend(o.slice(1),a,n);u.push(...l),d.push(...h)}const p=n?this.getFeesForProofs(u):0;return D(u)<e+p&&i&&(u=[i]),{keep:t.filter(h=>!u.includes(h)),send:u}}getFeesForProofs(t){if(!this._keysets.length)throw new Error("Could not calculate fees. No keysets found");return new Set(t.map(r=>r.id)).forEach(r=>{if(!this._keysets.find(o=>o.id===r))throw new Error(`Could not calculate fees. No keyset found with id: ${r}`)}),Math.floor(Math.max((t.reduce((r,o)=>r+(this._keysets.find(c=>c.id===o.id)?.input_fee_ppk||0),0)+999)/1e3,0))}getFeesForKeyset(t,e){return Math.floor(Math.max((t*(this._keysets.find(r=>r.id===e)?.input_fee_ppk||0)+999)/1e3,0))}async swap(t,e,n){let{outputAmounts:r}=n||{};const{includeFees:o,keysetId:c,counter:i,pubkey:a,privkey:u,proofsWeHave:d,outputData:f,p2pk:p}=n||{},h=await this.getKeys(c),l=e;let k=t;const m=D(e);let g=m-k-this.getFeesForProofs(l),b=r?.sendAmounts||T(k,h.keys);if(o){let E=this.getFeesForKeyset(b.length,h.id),v=T(E,h.keys);for(;this.getFeesForKeyset(b.concat(v).length,h.id)>E;)E++,v=T(E,h.keys);b=b.concat(v),k+=E,g-=E}let y;if(!r?.keepAmounts&&d)y=ft(d,g,h.keys,this._denominationTarget);else if(r){if(r.keepAmounts?.reduce((E,v)=>E+v,0)!=g)throw new Error("Keep amounts do not match amount to keep");y=r.keepAmounts}if(k+this.getFeesForProofs(l)>m)throw console.error(`Not enough funds available (${m}) for swap amountToSend: ${k} + fee: ${this.getFeesForProofs(l)} | length: ${l.length}`),new Error("Not enough funds available for swap");if(k+this.getFeesForProofs(l)+g!=m)throw new Error("Amounts do not match for swap");r={keepAmounts:y,sendAmounts:b};const A=f?.keep||this._keepFactory,K=f?.send,L=this.createSwapPayload(k,l,h,r,i,a,u,{keep:A,send:K},p),{signatures:Ot}=await this.mint.swap(L.payload),at=L.outputData.map((E,v)=>E.toProof(Ot[v],h)),ut=[],ht=[],dt=Array(L.keepVector.length),lt=Array(at.length);return L.sortedIndices.forEach((E,v)=>{dt[E]=L.keepVector[v],lt[E]=at[v]}),lt.forEach((E,v)=>{dt[v]?ut.push(E):ht.push(E)}),{keep:ut,send:ht}}async batchRestore(t=300,e=100,n=0,r){const o=Math.ceil(t/e),c=[];let i,a=0;for(;a<o;){const u=await this.restore(n,e,{keysetId:r});u.proofs.length>0?(a=0,c.push(...u.proofs),i=u.lastCounterWithSignature):a++,n+=e}return{proofs:c,lastCounterWithSignature:i}}async restore(t,e,n){const{keysetId:r}=n||{},o=await this.getKeys(r);if(!this._seed)throw new Error("CashuWallet must be initialized with a seed to use restore");const c=Array(e).fill(1),i=B.createDeterministicData(c.length,this._seed,t,o,c),{outputs:a,signatures:u}=await this.mint.restore({outputs:i.map(h=>h.blindedMessage)}),d={};a.forEach((h,l)=>d[h.B_]=u[l]);const f=[];let p;for(let h=0;h<i.length;h++){const l=d[i[h].blindedMessage.B_];l&&(p=t+h,i[h].blindedMessage.amount=l.amount,f.push(i[h].toProof(l,o)))}return{proofs:f,lastCounterWithSignature:p}}async createMintQuote(t,e){const n={unit:this._unit,amount:t,description:e},r=await this.mint.createMintQuote(n);return{...r,amount:r.amount||t,unit:r.unit||this.unit}}async createLockedMintQuote(t,e,n){const{supported:r}=(await this.getMintInfo()).isSupported(20);if(!r)throw new Error("Mint does not support NUT-20");const o={unit:this._unit,amount:t,description:n,pubkey:e},c=await this.mint.createMintQuote(o);if(typeof c.pubkey!="string")throw new Error("Mint returned unlocked mint quote");{const i=c.pubkey;return{...c,pubkey:i,amount:c.amount||t,unit:c.unit||this.unit}}}async checkMintQuote(t){const e=typeof t=="string"?t:t.quote,n=await this.mint.checkMintQuote(e);return typeof t=="string"?n:{...n,amount:n.amount||t.amount,unit:n.unit||t.unit}}async mintProofs(t,e,n){let{outputAmounts:r}=n||{};const{counter:o,pubkey:c,p2pk:i,keysetId:a,proofsWeHave:u,outputData:d,privateKey:f}=n||{},p=await this.getKeys(a);!r&&u&&(r={keepAmounts:ft(u,t,p.keys,this._denominationTarget),sendAmounts:[]});let h=[];if(d)if(tt(d)){const m=T(t,p.keys,r?.keepAmounts);for(let g=0;g<m.length;g++)h.push(d(m[g],p))}else h=d;else if(this._keepFactory){const m=T(t,p.keys,r?.keepAmounts);for(let g=0;g<m.length;g++)h.push(this._keepFactory(m[g],p))}else h=this.createOutputData(t,p,o,c,r?.keepAmounts,i);let l;if(typeof e!="string"){if(!f)throw new Error("Can not sign locked quote without private key");const m=h.map(b=>b.blindedMessage),g=Ne(f,e.quote,m);l={outputs:m,quote:e.quote,signature:g}}else l={outputs:h.map(m=>m.blindedMessage),quote:e};const{signatures:k}=await this.mint.mint(l);return h.map((m,g)=>m.toProof(k[g],p))}async createMeltQuote(t){const e={unit:this._unit,request:t},n=await this.mint.createMeltQuote(e);return{...n,unit:n.unit||this.unit,request:n.request||t}}async createMultiPathMeltQuote(t,e){const{supported:n,params:r}=(await this.lazyGetMintInfo()).isSupported(15);if(!n)throw new Error("Mint does not support NUT-15");if(!r?.some(u=>u.method==="bolt11"&&u.unit===this.unit))throw new Error(`Mint does not support MPP for bolt11 and ${this.unit}`);const c={mpp:{amount:e}},i={unit:this._unit,request:t,options:c};return{...await this.mint.createMeltQuote(i),request:t,unit:this._unit}}async checkMeltQuote(t){const e=typeof t=="string"?t:t.quote,n=await this.mint.checkMeltQuote(e);return typeof t=="string"?n:{...n,request:t.request,unit:t.unit}}async meltProofs(t,e,n){const{keysetId:r,counter:o,privkey:c}=n||{},i=await this.getKeys(r),a=this.createBlankOutputs(D(e)-t.amount,i,o,this._keepFactory);c!=null&&(e=gt(e.map(f=>({amount:f.amount,C:U(f.C),id:f.id,secret:new TextEncoder().encode(f.secret)})),c).map(f=>st(f))),e=C(e);const u={quote:t.quote,inputs:e,outputs:a.map(f=>f.blindedMessage)},d=await this.mint.melt(u);return{quote:{...d,unit:t.unit,request:t.request},change:d.change?.map((f,p)=>a[p].toProof(f,i))??[]}}createSwapPayload(t,e,n,r,o,c,i,a,u){const d=e.reduce((y,A)=>y+A.amount,0);r&&r.sendAmounts&&!r.keepAmounts&&(r.keepAmounts=T(d-t-this.getFeesForProofs(e),n.keys));const f=d-t-this.getFeesForProofs(e);let p=[],h=[];if(a?.keep)if(tt(a.keep)){const y=a.keep;T(f,n.keys).forEach(K=>{p.push(y(K,n))})}else p=a.keep;else p=this.createOutputData(f,n,o,void 0,r?.keepAmounts,void 0,this._keepFactory);if(a?.send)if(tt(a.send)){const y=a.send;T(t,n.keys).forEach(K=>{h.push(y(K,n))})}else h=a.send;else h=this.createOutputData(t,n,o?o+p.length:void 0,c,r?.sendAmounts,u);i&&(e=gt(e.map(y=>({amount:y.amount,C:U(y.C),id:y.id,secret:new TextEncoder().encode(y.secret)})),i).map(y=>st(y))),e=C(e);const l=[...p,...h],k=l.map((y,A)=>A).sort((y,A)=>l[y].blindedMessage.amount-l[A].blindedMessage.amount),m=[...Array(p.length).fill(!0),...Array(h.length).fill(!1)],g=k.map(y=>l[y]),b=k.map(y=>m[y]);return{payload:{inputs:e,outputs:g.map(y=>y.blindedMessage)},outputData:g,keepVector:b,sortedIndices:k}}async checkProofsStates(t){const e=new TextEncoder,n=t.map(c=>j(e.encode(c.secret)).toHex(!0)),r=100,o=[];for(let c=0;c<n.length;c+=r){const i=n.slice(c,c+r),{states:a}=await this.mint.check({Ys:i}),u={};a.forEach(d=>{u[d.Y]=d});for(let d=0;d<i.length;d++){const f=u[i[d]];if(!f)throw new Error("Could not find state for proof with Y: "+i[d]);o.push(f)}}return o}async onMintQuoteUpdates(t,e,n){if(await this.mint.connectWebSocket(),!this.mint.webSocketConnection)throw new Error("failed to establish WebSocket connection.");const r=this.mint.webSocketConnection.createSubscription({kind:"bolt11_mint_quote",filters:t},e,n);return()=>{this.mint.webSocketConnection?.cancelSubscription(r,e)}}async onMeltQuotePaid(t,e,n){return this.onMeltQuoteUpdates([t],r=>{r.state===F.PAID&&e(r)},n)}async onMintQuotePaid(t,e,n){return this.onMintQuoteUpdates([t],r=>{r.state===z.PAID&&e(r)},n)}async onMeltQuoteUpdates(t,e,n){if(await this.mint.connectWebSocket(),!this.mint.webSocketConnection)throw new Error("failed to establish WebSocket connection.");const r=this.mint.webSocketConnection.createSubscription({kind:"bolt11_melt_quote",filters:t},e,n);return()=>{this.mint.webSocketConnection?.cancelSubscription(r,e)}}async onProofStateUpdates(t,e,n){if(await this.mint.connectWebSocket(),!this.mint.webSocketConnection)throw new Error("failed to establish WebSocket connection.");const r=new TextEncoder,o={};for(let a=0;a<t.length;a++){const u=j(r.encode(t[a].secret)).toHex(!0);o[u]=t[a]}const c=Object.keys(o),i=this.mint.webSocketConnection.createSubscription({kind:"proof_state",filters:c},a=>{e({...a,proof:o[a.Y]})},n);return()=>{this.mint.webSocketConnection?.cancelSubscription(i,e)}}createOutputData(t,e,n,r,o,c,i){let a;if(r)a=B.createP2PKData({pubkey:r},t,e,o);else if(n||n===0){if(!this._seed)throw new Error("cannot create deterministic messages without seed");a=B.createDeterministicData(t,this._seed,n,e,o)}else c?a=B.createP2PKData(c,t,e,o):i?a=T(t,e.keys).map(d=>i(d,e)):a=B.createRandomData(t,e,o);return a}createBlankOutputs(t,e,n,r){let o=Math.ceil(Math.log2(t))||1;o<0&&(o=0);const c=o?Array(o).fill(1):[];return this.createOutputData(c.length,e,n,void 0,c,void 0,r)}}class O{constructor(t,e){this._mintUrl=t,this._customRequest=e,this._mintUrl=xt(t),this._customRequest=e}get mintUrl(){return this._mintUrl}static async mint(t,e,n,r){const o=r||P,c={"Clear-auth":`${n}`},i=await o({endpoint:_(t,"/v1/auth/blind/mint"),method:"POST",requestBody:e,headers:c});if(!q(i)||!Array.isArray(i?.signatures))throw new Error("bad response");return i}async mint(t,e){return O.mint(this._mintUrl,t,e,this._customRequest)}static async getKeys(t,e,n){const o=await(n||P)({endpoint:e?_(t,"/v1/auth/blind/keys",e):_(t,"/v1/auth/blind/keys")});if(!q(o)||!Array.isArray(o.keysets))throw new Error("bad response");return o}async getKeys(t,e){return await O.getKeys(e||this._mintUrl,t,this._customRequest)}static async getKeySets(t,e){return(e||P)({endpoint:_(t,"/v1/auth/blind/keysets")})}async getKeySets(){return O.getKeySets(this._mintUrl,this._customRequest)}}class Ut{constructor(t,e){this._keys=new Map,this._keysets=[],this._unit="auth",this.mint=t;let n=[];e?.keys&&!Array.isArray(e.keys)?n=[e.keys]:e?.keys&&Array.isArray(e?.keys)&&(n=e?.keys),n&&n.forEach(r=>this._keys.set(r.id,r)),e?.keysets&&(this._keysets=e.keysets)}get keys(){return this._keys}get keysetId(){if(!this._keysetId)throw new Error("No keysetId set");return this._keysetId}set keysetId(t){this._keysetId=t}get keysets(){return this._keysets}async loadMint(){await this.getKeySets(),await this.getKeys()}getActiveKeyset(t){let e=t.filter(r=>r.active);e=e.filter(r=>r.id.startsWith("00"));const n=e.sort((r,o)=>(r.input_fee_ppk??0)-(o.input_fee_ppk??0))[0];if(!n)throw new Error("No active keyset found");return n}async getKeySets(){const e=(await this.mint.getKeySets()).keysets.filter(n=>n.unit===this._unit);return this._keysets=e,this._keysets}async getAllKeys(){const t=await this.mint.getKeys();return this._keys=new Map(t.keysets.map(e=>[e.id,e])),this.keysetId=this.getActiveKeyset(this._keysets).id,t.keysets}async getKeys(t,e){if((!(this._keysets.length>0)||e)&&await this.getKeySets(),t||(t=this.getActiveKeyset(this._keysets).id),!this._keysets.find(n=>n.id===t)&&(await this.getKeySets(),!this._keysets.find(n=>n.id===t)))throw new Error(`could not initialize keys. No keyset with id '${t}' found`);if(!this._keys.get(t)){const n=await this.mint.getKeys(t);this._keys.set(t,n.keysets[0])}return this.keysetId=t,this._keys.get(t)}async mintProofs(t,e,n){const r=await this.getKeys(n?.keysetId),o=B.createRandomData(t,r),c={outputs:o.map(u=>u.blindedMessage)},{signatures:i}=await this.mint.mint(c,e),a=o.map((u,d)=>u.toProof(i[d],r));if(a.some(u=>!it(u,r)))throw new Error("Mint returned auth proofs with invalid DLEQ");return a}}function Nt(s){const t={id:s.id,secret:s.secret,C:s.C},e=bt(t);return"auth"+"A"+e}async function We(s,t,e){const n=new O(t);return(await new Ut(n).mintProofs(s,e)).map(c=>Nt(c))}exports.CashuAuthMint=O;exports.CashuAuthWallet=Ut;exports.CashuMint=S;exports.CashuWallet=Le;exports.CheckStateEnum=Te;exports.HttpResponseError=Q;exports.MeltQuoteState=F;exports.MintOperationError=J;exports.MintQuoteState=z;exports.NetworkError=V;exports.OutputData=B;exports.PaymentRequest=G;exports.PaymentRequestTransportType=Mt;exports.decodePaymentRequest=ge;exports.deriveKeysetId=pe;exports.getBlindedAuthToken=We;exports.getDecodedToken=qt;exports.getDecodedTokenBinary=Ee;exports.getEncodedAuthToken=Nt;exports.getEncodedToken=fe;exports.getEncodedTokenBinary=_e;exports.getEncodedTokenV4=vt;exports.hasValidDleq=it;exports.injectWebSocketImpl=Se;exports.setGlobalRequestOptions=ve;
//# sourceMappingURL=cashu-ts.cjs.js.map
