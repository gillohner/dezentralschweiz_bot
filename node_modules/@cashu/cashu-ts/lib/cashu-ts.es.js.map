{"version":3,"file":"cashu-ts.es.js","sources":["../src/crypto/util/utils.ts","../src/crypto/common/index.ts","../src/crypto/client/NUT12.ts","../src/base64.ts","../src/cbor.ts","../src/model/PaymentRequest.ts","../src/utils/Constants.ts","../src/utils.ts","../src/ws.ts","../src/WSConnection.ts","../src/model/types/mint/responses.ts","../src/model/types/wallet/paymentRequests.ts","../src/model/Errors.ts","../src/request.ts","../src/legacy/nut-05.ts","../src/legacy/nut-04.ts","../src/legacy/nut-06.ts","../src/model/MintInfo.ts","../src/CashuMint.ts","../src/crypto/common/NUT11.ts","../src/crypto/client/NUT11.ts","../src/crypto/client/index.ts","../src/crypto/client/NUT20.ts","../src/model/BlindedMessage.ts","../src/crypto/client/NUT09.ts","../src/model/OutputData.ts","../src/CashuWallet.ts","../src/auth/CashuAuthMint.ts","../src/auth/CashuAuthWallet.ts","../src/auth/index.ts"],"sourcesContent":["import { bytesToHex } from '@noble/curves/abstract/utils';\nimport { Buffer } from 'buffer';\n\nexport function bytesToNumber(bytes: Uint8Array): bigint {\n\treturn hexToNumber(bytesToHex(bytes));\n}\n\nexport function hexToNumber(hex: string): bigint {\n\treturn BigInt(`0x${hex}`);\n}\n\nexport function encodeBase64toUint8(base64String: string): Uint8Array {\n\treturn Buffer.from(base64String, 'base64');\n}\n","import { ProjPointType } from '@noble/curves/abstract/weierstrass';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { bytesToHex, hexToBytes } from '@noble/curves/abstract/utils';\nimport { bytesToNumber, encodeBase64toUint8, hexToNumber } from '../util/utils.js';\nimport { Buffer } from 'buffer';\n\nexport type Enumerate<N extends number, Acc extends number[] = []> = Acc['length'] extends N\n\t? Acc[number]\n\t: Enumerate<N, [...Acc, Acc['length']]>;\n\nexport type IntRange<F extends number, T extends number> = Exclude<Enumerate<T>, Enumerate<F>>;\n\nexport type MintKeys = { [k: string]: Uint8Array };\n\nexport type SerializedMintKeys = {\n\t[k: string]: string;\n};\n\nexport type Keyset = {\n\tid: string;\n\tunit: string;\n\tactive: boolean;\n};\n\nexport type BlindSignature = {\n\tC_: ProjPointType<bigint>;\n\tamount: number;\n\tid: string;\n};\n\nexport type SerializedBlindSignature = {\n\tC_: string;\n\tamount: number;\n\tid: string;\n};\n\nexport type DLEQ = {\n\ts: Uint8Array; // signature\n\te: Uint8Array; // challenge\n\tr?: bigint; // optional: blinding factor\n};\n\nexport type Proof = {\n\tC: ProjPointType<bigint>;\n\tsecret: Uint8Array;\n\tamount: number;\n\tid: string;\n\twitness?: Witness;\n};\n\nexport type SerializedProof = {\n\tC: string;\n\tsecret: string;\n\tamount: number;\n\tid: string;\n\twitness?: string;\n};\n\nexport type SerializedBlindedMessage = {\n\tB_: string;\n\tamount: number;\n\twitness?: string;\n};\n\nexport type Secret = [WellKnownSecret, SecretData];\n\nexport type WellKnownSecret = 'P2PK';\n\nexport type SecretData = {\n\tnonce: string;\n\tdata: string;\n\ttags?: Array<Array<string>>;\n};\n\nexport type Witness = {\n\tsignatures: Array<string>;\n};\n\nexport type Tags = {\n\t[k: string]: string;\n};\n\nexport type SigFlag = 'SIG_INPUTS' | 'SIG_ALL';\n\nconst DOMAIN_SEPARATOR = hexToBytes('536563703235366b315f48617368546f43757276655f43617368755f');\n\nexport function hashToCurve(secret: Uint8Array): ProjPointType<bigint> {\n\tconst msgToHash = sha256(Buffer.concat([DOMAIN_SEPARATOR, secret]));\n\tconst counter = new Uint32Array(1);\n\tconst maxIterations = 2 ** 16;\n\tfor (let i = 0; i < maxIterations; i++) {\n\t\tconst counterBytes = new Uint8Array(counter.buffer);\n\t\tconst hash = sha256(Buffer.concat([msgToHash, counterBytes]));\n\t\ttry {\n\t\t\treturn pointFromHex(bytesToHex(Buffer.concat([new Uint8Array([0x02]), hash])));\n\t\t} catch (error) {\n\t\t\tcounter[0]++;\n\t\t}\n\t}\n\tthrow new Error('No valid point found');\n}\n\nexport function hash_e(pubkeys: Array<ProjPointType<bigint>>): Uint8Array {\n\tconst hexStrings = pubkeys.map((p) => p.toHex(false));\n\tconst e_ = hexStrings.join('');\n\tconst e = sha256(new TextEncoder().encode(e_));\n\treturn e;\n}\n\nexport function pointFromBytes(bytes: Uint8Array) {\n\treturn secp256k1.ProjectivePoint.fromHex(bytesToHex(bytes));\n}\n\nexport function pointFromHex(hex: string) {\n\treturn secp256k1.ProjectivePoint.fromHex(hex);\n}\n\nexport const getKeysetIdInt = (keysetId: string): bigint => {\n\tlet keysetIdInt: bigint;\n\tif (/^[a-fA-F0-9]+$/.test(keysetId)) {\n\t\tkeysetIdInt = hexToNumber(keysetId) % BigInt(2 ** 31 - 1);\n\t} else {\n\t\t//legacy keyset compatibility\n\t\tkeysetIdInt = bytesToNumber(encodeBase64toUint8(keysetId)) % BigInt(2 ** 31 - 1);\n\t}\n\treturn keysetIdInt;\n};\n\nexport function createRandomPrivateKey() {\n\treturn secp256k1.utils.randomPrivateKey();\n}\n\nexport function serializeMintKeys(mintKeys: MintKeys): SerializedMintKeys {\n\tconst serializedMintKeys: SerializedMintKeys = {};\n\tObject.keys(mintKeys).forEach((p) => {\n\t\tserializedMintKeys[p] = bytesToHex(mintKeys[p]);\n\t});\n\treturn serializedMintKeys;\n}\n\nexport function deserializeMintKeys(serializedMintKeys: SerializedMintKeys): MintKeys {\n\tconst mintKeys: MintKeys = {};\n\tObject.keys(serializedMintKeys).forEach((p) => {\n\t\tmintKeys[p] = hexToBytes(serializedMintKeys[p]);\n\t});\n\treturn mintKeys;\n}\n\nexport function deriveKeysetId(keys: MintKeys): string {\n\tconst KEYSET_VERSION = '00';\n\tconst mapBigInt = (k: [string, string]): [bigint, string] => {\n\t\treturn [BigInt(k[0]), k[1]];\n\t};\n\tconst pubkeysConcat = Object.entries(serializeMintKeys(keys))\n\t\t.map(mapBigInt)\n\t\t.sort((a, b) => (a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0))\n\t\t.map(([, pubKey]) => hexToBytes(pubKey))\n\t\t.reduce((prev, curr) => mergeUInt8Arrays(prev, curr), new Uint8Array());\n\tconst hash = sha256(pubkeysConcat);\n\tconst hashHex = Buffer.from(hash).toString('hex').slice(0, 14);\n\treturn '00' + hashHex;\n}\n\nfunction mergeUInt8Arrays(a1: Uint8Array, a2: Uint8Array): Uint8Array {\n\t// sum of individual array lengths\n\tconst mergedArray = new Uint8Array(a1.length + a2.length);\n\tmergedArray.set(a1);\n\tmergedArray.set(a2, a1.length);\n\treturn mergedArray;\n}\n","import { DLEQ, hash_e, hashToCurve } from '../common/index.js';\nimport { ProjPointType } from '@noble/curves/abstract/weierstrass';\nimport { bytesToHex } from '@noble/curves/abstract/utils';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { bytesToNumber } from '../util/utils.js';\n\nfunction arraysEqual(arr1: any, arr2: any) {\n\tif (arr1.length !== arr2.length) return false;\n\tfor (let i = 0; i < arr1.length; i++) {\n\t\tif (arr1[i] !== arr2[i]) return false;\n\t}\n\treturn true;\n}\n\nexport const verifyDLEQProof = (\n\tdleq: DLEQ,\n\tB_: ProjPointType<bigint>,\n\tC_: ProjPointType<bigint>,\n\tA: ProjPointType<bigint>\n) => {\n\tconst sG = secp256k1.ProjectivePoint.fromPrivateKey(bytesToHex(dleq.s));\n\tconst eA = A.multiply(bytesToNumber(dleq.e));\n\tconst sB_ = B_.multiply(bytesToNumber(dleq.s));\n\tconst eC_ = C_.multiply(bytesToNumber(dleq.e));\n\tconst R_1 = sG.subtract(eA); // R1 = sG - eA\n\tconst R_2 = sB_.subtract(eC_); // R2 = sB' - eC'\n\tconst hash = hash_e([R_1, R_2, A, C_]); // e == hash(R1, R2, A, C')\n\treturn arraysEqual(hash, dleq.e);\n};\n\nexport const verifyDLEQProof_reblind = (\n\tsecret: Uint8Array, // secret\n\tdleq: DLEQ,\n\tC: ProjPointType<bigint>, // unblinded e-cash signature point\n\tA: ProjPointType<bigint> // mint public key point\n) => {\n\tif (dleq.r === undefined) throw new Error('verifyDLEQProof_reblind: Undefined blinding factor');\n\tconst Y = hashToCurve(secret);\n\tconst C_ = C.add(A.multiply(dleq.r)); // Re-blind the e-cash signature\n\tconst bG = secp256k1.ProjectivePoint.fromPrivateKey(dleq.r);\n\tconst B_ = Y.add(bG); // Re-blind the message\n\treturn verifyDLEQProof(dleq, B_, C_, A);\n};\n","import { Buffer } from 'buffer';\n\nfunction encodeUint8toBase64(uint8array: Uint8Array): string {\n\treturn Buffer.from(uint8array).toString('base64');\n}\n\nfunction encodeUint8toBase64Url(bytes: Uint8Array): string {\n\treturn Buffer.from(bytes)\n\t\t.toString('base64')\n\t\t.replace(/\\+/g, '-') // Replace + with -\n\t\t.replace(/\\//g, '_') // Replace / with _\n\t\t.replace(/=+$/, ''); // Remove padding characters\n}\n\nfunction encodeBase64toUint8(base64String: string): Uint8Array {\n\treturn Buffer.from(base64String, 'base64');\n}\n\nfunction encodeJsonToBase64(jsonObj: unknown): string {\n\tconst jsonString = JSON.stringify(jsonObj);\n\treturn base64urlFromBase64(Buffer.from(jsonString).toString('base64'));\n}\n\nfunction encodeBase64ToJson<T extends object>(base64String: string): T {\n\tconst jsonString = Buffer.from(base64urlToBase64(base64String), 'base64').toString();\n\tconst jsonObj = JSON.parse(jsonString) as T;\n\treturn jsonObj;\n}\n\nfunction base64urlToBase64(str: string) {\n\treturn str.replace(/-/g, '+').replace(/_/g, '/').split('=')[0];\n\t// .replace(/./g, '=');\n}\n\nfunction base64urlFromBase64(str: string) {\n\treturn str.replace(/\\+/g, '-').replace(/\\//g, '_').split('=')[0];\n\t// .replace(/=/g, '.');\n}\n\nexport {\n\tencodeUint8toBase64,\n\tencodeUint8toBase64Url,\n\tencodeBase64toUint8,\n\tencodeJsonToBase64,\n\tencodeBase64ToJson\n};\n","type SimpleValue = boolean | null | undefined;\n\nexport type ResultObject = { [key: string]: ResultValue };\nexport type ResultValue =\n\t| SimpleValue\n\t| number\n\t| string\n\t| Uint8Array\n\t| Array<ResultValue>\n\t| ResultObject;\n\ntype ResultKeyType = Extract<ResultValue, number | string>;\nexport type ValidDecodedType = Extract<ResultValue, ResultObject>;\n\nfunction isResultKeyType(value: ResultValue): value is ResultKeyType {\n\treturn typeof value === 'number' || typeof value === 'string';\n}\n\ntype DecodeResult<T extends ResultValue> = {\n\tvalue: T;\n\toffset: number;\n};\n\nexport function encodeCBOR(value: any) {\n\tconst buffer: Array<number> = [];\n\tencodeItem(value, buffer);\n\treturn new Uint8Array(buffer);\n}\n\nfunction encodeItem(value: any, buffer: Array<number>) {\n\tif (value === null) {\n\t\tbuffer.push(0xf6);\n\t} else if (value === undefined) {\n\t\tbuffer.push(0xf7);\n\t} else if (typeof value === 'boolean') {\n\t\tbuffer.push(value ? 0xf5 : 0xf4);\n\t} else if (typeof value === 'number') {\n\t\tencodeUnsigned(value, buffer);\n\t} else if (typeof value === 'string') {\n\t\tencodeString(value, buffer);\n\t} else if (Array.isArray(value)) {\n\t\tencodeArray(value, buffer);\n\t} else if (value instanceof Uint8Array) {\n\t\tencodeByteString(value, buffer);\n\t} else if (typeof value === 'object') {\n\t\tencodeObject(value, buffer);\n\t} else {\n\t\tthrow new Error('Unsupported type');\n\t}\n}\n\nfunction encodeUnsigned(value: number, buffer: Array<number>) {\n\tif (value < 24) {\n\t\tbuffer.push(value);\n\t} else if (value < 256) {\n\t\tbuffer.push(0x18, value);\n\t} else if (value < 65536) {\n\t\tbuffer.push(0x19, value >> 8, value & 0xff);\n\t} else if (value < 4294967296) {\n\t\tbuffer.push(0x1a, value >> 24, (value >> 16) & 0xff, (value >> 8) & 0xff, value & 0xff);\n\t} else {\n\t\tthrow new Error('Unsupported integer size');\n\t}\n}\n\nfunction encodeByteString(value: Uint8Array, buffer: Array<number>) {\n\tconst length = value.length;\n\n\tif (length < 24) {\n\t\tbuffer.push(0x40 + length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0x58, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0x59, (length >> 8) & 0xff, length & 0xff);\n\t} else if (length < 4294967296) {\n\t\tbuffer.push(\n\t\t\t0x5a,\n\t\t\t(length >> 24) & 0xff,\n\t\t\t(length >> 16) & 0xff,\n\t\t\t(length >> 8) & 0xff,\n\t\t\tlength & 0xff\n\t\t);\n\t} else {\n\t\tthrow new Error('Byte string too long to encode');\n\t}\n\n\tfor (let i = 0; i < value.length; i++) {\n\t\tbuffer.push(value[i]);\n\t}\n}\n\nfunction encodeString(value: string, buffer: Array<number>) {\n\tconst utf8 = new TextEncoder().encode(value);\n\tconst length = utf8.length;\n\n\tif (length < 24) {\n\t\tbuffer.push(0x60 + length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0x78, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0x79, (length >> 8) & 0xff, length & 0xff);\n\t} else if (length < 4294967296) {\n\t\tbuffer.push(\n\t\t\t0x7a,\n\t\t\t(length >> 24) & 0xff,\n\t\t\t(length >> 16) & 0xff,\n\t\t\t(length >> 8) & 0xff,\n\t\t\tlength & 0xff\n\t\t);\n\t} else {\n\t\tthrow new Error('String too long to encode');\n\t}\n\n\tfor (let i = 0; i < utf8.length; i++) {\n\t\tbuffer.push(utf8[i]);\n\t}\n}\n\nfunction encodeArray(value: Array<any>, buffer: Array<number>) {\n\tconst length = value.length;\n\tif (length < 24) {\n\t\tbuffer.push(0x80 | length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0x98, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0x99, length >> 8, length & 0xff);\n\t} else {\n\t\tthrow new Error('Unsupported array length');\n\t}\n\n\tfor (const item of value) {\n\t\tencodeItem(item, buffer);\n\t}\n}\n\nfunction encodeObject(value: { [key: string]: any }, buffer: Array<number>) {\n\tconst keys = Object.keys(value);\n\tencodeUnsigned(keys.length, buffer);\n\tbuffer[buffer.length - 1] |= 0xa0;\n\tfor (const key of keys) {\n\t\tencodeString(key, buffer);\n\t\tencodeItem(value[key], buffer);\n\t}\n}\n\nexport function decodeCBOR(data: Uint8Array): ResultValue {\n\tconst view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n\tconst result = decodeItem(view, 0);\n\treturn result.value;\n}\n\nfunction decodeItem(view: DataView, offset: number): DecodeResult<ResultValue> {\n\tif (offset >= view.byteLength) {\n\t\tthrow new Error('Unexpected end of data');\n\t}\n\tconst initialByte = view.getUint8(offset++);\n\tconst majorType = initialByte >> 5;\n\tconst additionalInfo = initialByte & 0x1f;\n\n\tswitch (majorType) {\n\t\tcase 0:\n\t\t\treturn decodeUnsigned(view, offset, additionalInfo);\n\t\tcase 1:\n\t\t\treturn decodeSigned(view, offset, additionalInfo);\n\t\tcase 2:\n\t\t\treturn decodeByteString(view, offset, additionalInfo);\n\t\tcase 3:\n\t\t\treturn decodeString(view, offset, additionalInfo);\n\t\tcase 4:\n\t\t\treturn decodeArray(view, offset, additionalInfo);\n\t\tcase 5:\n\t\t\treturn decodeMap(view, offset, additionalInfo);\n\t\tcase 7:\n\t\t\treturn decodeSimpleAndFloat(view, offset, additionalInfo);\n\t\tdefault:\n\t\t\tthrow new Error(`Unsupported major type: ${majorType}`);\n\t}\n}\n\nfunction decodeLength(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number\n): DecodeResult<number> {\n\tif (additionalInfo < 24) return { value: additionalInfo, offset };\n\tif (additionalInfo === 24) return { value: view.getUint8(offset++), offset };\n\tif (additionalInfo === 25) {\n\t\tconst value = view.getUint16(offset, false);\n\t\toffset += 2;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 26) {\n\t\tconst value = view.getUint32(offset, false);\n\t\toffset += 4;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 27) {\n\t\tconst hi = view.getUint32(offset, false);\n\t\tconst lo = view.getUint32(offset + 4, false);\n\t\toffset += 8;\n\t\treturn { value: hi * 2 ** 32 + lo, offset };\n\t}\n\tthrow new Error(`Unsupported length: ${additionalInfo}`);\n}\n\nfunction decodeUnsigned(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number\n): DecodeResult<number> {\n\tconst { value, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\treturn { value, offset: newOffset };\n}\n\nfunction decodeSigned(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number\n): DecodeResult<number> {\n\tconst { value, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\treturn { value: -1 - value, offset: newOffset };\n}\n\nfunction decodeByteString(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number\n): DecodeResult<Uint8Array> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tif (newOffset + length > view.byteLength) {\n\t\tthrow new Error('Byte string length exceeds data length');\n\t}\n\tconst value = new Uint8Array(view.buffer, view.byteOffset + newOffset, length);\n\treturn { value, offset: newOffset + length };\n}\n\nfunction decodeString(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number\n): DecodeResult<string> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tif (newOffset + length > view.byteLength) {\n\t\tthrow new Error('String length exceeds data length');\n\t}\n\tconst bytes = new Uint8Array(view.buffer, view.byteOffset + newOffset, length);\n\tconst value = new TextDecoder().decode(bytes);\n\treturn { value, offset: newOffset + length };\n}\n\nfunction decodeArray(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number\n): DecodeResult<Array<ResultValue>> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tconst array = [];\n\tlet currentOffset = newOffset;\n\tfor (let i = 0; i < length; i++) {\n\t\tconst result = decodeItem(view, currentOffset);\n\t\tarray.push(result.value);\n\t\tcurrentOffset = result.offset;\n\t}\n\treturn { value: array, offset: currentOffset };\n}\n\nfunction decodeMap(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number\n): DecodeResult<Record<string, ResultValue>> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tconst map: { [key: string]: ResultValue } = {};\n\tlet currentOffset = newOffset;\n\tfor (let i = 0; i < length; i++) {\n\t\tconst keyResult = decodeItem(view, currentOffset);\n\t\tif (!isResultKeyType(keyResult.value)) {\n\t\t\tthrow new Error('Invalid key type');\n\t\t}\n\t\tconst valueResult = decodeItem(view, keyResult.offset);\n\t\tmap[keyResult.value] = valueResult.value;\n\t\tcurrentOffset = valueResult.offset;\n\t}\n\treturn { value: map, offset: currentOffset };\n}\n\nfunction decodeFloat16(uint16: number): number {\n\tconst exponent = (uint16 & 0x7c00) >> 10;\n\tconst fraction = uint16 & 0x03ff;\n\tconst sign = uint16 & 0x8000 ? -1 : 1;\n\n\tif (exponent === 0) {\n\t\treturn sign * 2 ** -14 * (fraction / 1024);\n\t} else if (exponent === 0x1f) {\n\t\treturn fraction ? NaN : sign * Infinity;\n\t}\n\treturn sign * 2 ** (exponent - 15) * (1 + fraction / 1024);\n}\n\nfunction decodeSimpleAndFloat(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number\n): DecodeResult<SimpleValue | number> {\n\tif (additionalInfo < 24) {\n\t\tswitch (additionalInfo) {\n\t\t\tcase 20:\n\t\t\t\treturn { value: false, offset };\n\t\t\tcase 21:\n\t\t\t\treturn { value: true, offset };\n\t\t\tcase 22:\n\t\t\t\treturn { value: null, offset };\n\t\t\tcase 23:\n\t\t\t\treturn { value: undefined, offset };\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown simple value: ${additionalInfo}`);\n\t\t}\n\t}\n\tif (additionalInfo === 24) return { value: view.getUint8(offset++), offset };\n\tif (additionalInfo === 25) {\n\t\tconst value = decodeFloat16(view.getUint16(offset, false));\n\t\toffset += 2;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 26) {\n\t\tconst value = view.getFloat32(offset, false);\n\t\toffset += 4;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 27) {\n\t\tconst value = view.getFloat64(offset, false);\n\t\toffset += 8;\n\t\treturn { value, offset };\n\t}\n\tthrow new Error(`Unknown simple or float value: ${additionalInfo}`);\n}\n","import { encodeBase64toUint8 } from '../base64';\nimport { decodeCBOR, encodeCBOR } from '../cbor';\nimport {\n\tRawPaymentRequest,\n\tRawTransport,\n\tNUT10Option,\n\tPaymentRequestTransport,\n\tPaymentRequestTransportType\n} from './types';\nimport { Buffer } from 'buffer';\n\nexport class PaymentRequest {\n\tconstructor(\n\t\tpublic transport?: Array<PaymentRequestTransport>,\n\t\tpublic id?: string,\n\t\tpublic amount?: number,\n\t\tpublic unit?: string,\n\t\tpublic mints?: Array<string>,\n\t\tpublic description?: string,\n\t\tpublic singleUse: boolean = false,\n\t\tpublic nut10?: NUT10Option\n\t) {}\n\n\ttoRawRequest() {\n\t\tconst rawRequest: RawPaymentRequest = {};\n\t\tif (this.transport) {\n\t\t\trawRequest.t = this.transport.map((t: PaymentRequestTransport) => ({\n\t\t\t\tt: t.type,\n\t\t\t\ta: t.target,\n\t\t\t\tg: t.tags\n\t\t\t}));\n\t\t}\n\t\tif (this.id) {\n\t\t\trawRequest.i = this.id;\n\t\t}\n\t\tif (this.amount) {\n\t\t\trawRequest.a = this.amount;\n\t\t}\n\t\tif (this.unit) {\n\t\t\trawRequest.u = this.unit;\n\t\t}\n\t\tif (this.mints) {\n\t\t\trawRequest.m = this.mints;\n\t\t}\n\t\tif (this.description) {\n\t\t\trawRequest.d = this.description;\n\t\t}\n\t\tif (this.singleUse) {\n\t\t\trawRequest.s = this.singleUse;\n\t\t}\n\t\tif (this.nut10) {\n\t\t\trawRequest.nut10 = {\n\t\t\t\tk: this.nut10.kind,\n\t\t\t\td: this.nut10.data,\n\t\t\t\tt: this.nut10.tags\n\t\t\t};\n\t\t}\n\t\treturn rawRequest;\n\t}\n\n\ttoEncodedRequest() {\n\t\tconst rawRequest: RawPaymentRequest = this.toRawRequest();\n\t\tconst data = encodeCBOR(rawRequest);\n\t\tconst encodedData = Buffer.from(data).toString('base64');\n\t\treturn 'creq' + 'A' + encodedData;\n\t}\n\n\tgetTransport(type: PaymentRequestTransportType) {\n\t\treturn this.transport?.find((t: PaymentRequestTransport) => t.type === type);\n\t}\n\n\tstatic fromRawRequest(rawPaymentRequest: RawPaymentRequest): PaymentRequest {\n\t\tconst transports = rawPaymentRequest.t\n\t\t\t? rawPaymentRequest.t.map((t: RawTransport) => ({\n\t\t\t\t\ttype: t.t,\n\t\t\t\t\ttarget: t.a,\n\t\t\t\t\ttags: t.g\n\t\t\t  }))\n\t\t\t: undefined;\n\t\tconst nut10 = rawPaymentRequest.nut10\n\t\t\t? {\n\t\t\t\t\tkind: rawPaymentRequest.nut10.k,\n\t\t\t\t\tdata: rawPaymentRequest.nut10.d,\n\t\t\t\t\ttags: rawPaymentRequest.nut10.t\n\t\t\t  }\n\t\t\t: undefined;\n\t\treturn new PaymentRequest(\n\t\t\ttransports,\n\t\t\trawPaymentRequest.i,\n\t\t\trawPaymentRequest.a,\n\t\t\trawPaymentRequest.u,\n\t\t\trawPaymentRequest.m,\n\t\t\trawPaymentRequest.d,\n\t\t\trawPaymentRequest.s,\n\t\t\tnut10\n\t\t);\n\t}\n\n\tstatic fromEncodedRequest(encodedRequest: string): PaymentRequest {\n\t\tif (!encodedRequest.startsWith('creq')) {\n\t\t\tthrow new Error('unsupported pr: invalid prefix');\n\t\t}\n\t\tconst version = encodedRequest[4];\n\t\tif (version !== 'A') {\n\t\t\tthrow new Error('unsupported pr version');\n\t\t}\n\t\tconst encodedData = encodedRequest.slice(5);\n\t\tconst data = encodeBase64toUint8(encodedData);\n\t\tconst decoded = decodeCBOR(data) as RawPaymentRequest;\n\t\treturn this.fromRawRequest(decoded);\n\t}\n}\n","/**\n * per protocol definition since tokenV3 tokens have a prefix and a version number\n */\nconst TOKEN_VERSION = 'A';\nconst TOKEN_PREFIX = 'cashu';\n\nexport { TOKEN_VERSION, TOKEN_PREFIX };\n","import { verifyDLEQProof_reblind } from './crypto/client/NUT12.js';\nimport { DLEQ, pointFromHex } from './crypto/common/index.js';\nimport { bytesToHex, hexToBytes } from '@noble/curves/abstract/utils';\nimport { sha256 } from '@noble/hashes/sha256';\nimport {\n\tencodeBase64ToJson,\n\tencodeBase64toUint8,\n\tencodeJsonToBase64,\n\tencodeUint8toBase64Url\n} from './base64.js';\nimport { decodeCBOR, encodeCBOR } from './cbor.js';\nimport { PaymentRequest } from './model/PaymentRequest.js';\nimport {\n\tDeprecatedToken,\n\tKeys,\n\tMintKeys,\n\tProof,\n\tSerializedDLEQ,\n\tToken,\n\tTokenV4Template,\n\tV4DLEQTemplate,\n\tV4InnerToken,\n\tV4ProofTemplate\n} from './model/types/index.js';\nimport { TOKEN_PREFIX, TOKEN_VERSION } from './utils/Constants.js';\n\n/**\n * Splits the amount into denominations of the provided @param keyset\n * @param value amount to split\n * @param keyset keys to look up split amounts\n * @param split? optional custom split amounts\n * @param order? optional order for split amounts (default: \"asc\")\n * @returns Array of split amounts\n * @throws Error if @param split amount is greater than @param value amount\n */\nexport function splitAmount(\n\tvalue: number,\n\tkeyset: Keys,\n\tsplit?: Array<number>,\n\torder?: 'desc' | 'asc'\n): Array<number> {\n\tif (split) {\n\t\tconst totalSplitAmount = sumArray(split);\n\t\tif (totalSplitAmount > value) {\n\t\t\tthrow new Error(`Split is greater than total amount: ${totalSplitAmount} > ${value}`);\n\t\t}\n\t\tif (split.some((amt) => !hasCorrespondingKey(amt, keyset))) {\n\t\t\tthrow new Error('Provided amount preferences do not match the amounts of the mint keyset.');\n\t\t}\n\t\tvalue = value - sumArray(split);\n\t} else {\n\t\tsplit = [];\n\t}\n\tconst sortedKeyAmounts = getKeysetAmounts(keyset, 'desc');\n\tsortedKeyAmounts.forEach((amt: number) => {\n\t\tconst q = Math.floor(value / amt);\n\t\tfor (let i = 0; i < q; ++i) split?.push(amt);\n\t\tvalue %= amt;\n\t});\n\treturn split.sort((a, b) => (order === 'desc' ? b - a : a - b));\n}\n\n/**\n * Creates a list of amounts to keep based on the proofs we have and the proofs we want to reach.\n * @param proofsWeHave complete set of proofs stored (from current mint)\n * @param amountToKeep amount to keep\n * @param keys keys of current keyset\n * @param targetCount the target number of proofs to reach\n * @returns an array of amounts to keep\n */\nexport function getKeepAmounts(\n\tproofsWeHave: Array<Proof>,\n\tamountToKeep: number,\n\tkeys: Keys,\n\ttargetCount: number\n): Array<number> {\n\t// determines amounts we need to reach the targetCount for each amount based on the amounts of the proofs we have\n\t// it tries to select amounts so that the proofs we have and the proofs we want reach the targetCount\n\tconst amountsWeWant: Array<number> = [];\n\tconst amountsWeHave = proofsWeHave.map((p: Proof) => p.amount);\n\tconst sortedKeyAmounts = getKeysetAmounts(keys, 'asc');\n\tsortedKeyAmounts.forEach((amt) => {\n\t\tconst countWeHave = amountsWeHave.filter((a) => a === amt).length;\n\t\tconst countWeWant = Math.max(targetCount - countWeHave, 0);\n\t\tfor (let i = 0; i < countWeWant; ++i) {\n\t\t\tif (amountsWeWant.reduce((a, b) => a + b, 0) + amt > amountToKeep) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tamountsWeWant.push(amt);\n\t\t}\n\t});\n\t// use splitAmount to fill the rest between the sum of amountsWeHave and amountToKeep\n\tconst amountDiff = amountToKeep - amountsWeWant.reduce((a, b) => a + b, 0);\n\tif (amountDiff) {\n\t\tconst remainingAmounts = splitAmount(amountDiff, keys);\n\t\tremainingAmounts.forEach((amt: number) => {\n\t\t\tamountsWeWant.push(amt);\n\t\t});\n\t}\n\tconst sortedAmountsWeWant = amountsWeWant.sort((a, b) => a - b);\n\treturn sortedAmountsWeWant;\n}\n/**\n * returns the amounts in the keyset sorted by the order specified\n * @param keyset to search in\n * @param order order to sort the amounts in\n * @returns the amounts in the keyset sorted by the order specified\n */\nexport function getKeysetAmounts(keyset: Keys, order: 'asc' | 'desc' = 'desc'): Array<number> {\n\tif (order == 'desc') {\n\t\treturn Object.keys(keyset)\n\t\t\t.map((k: string) => parseInt(k))\n\t\t\t.sort((a: number, b: number) => b - a);\n\t}\n\treturn Object.keys(keyset)\n\t\t.map((k: string) => parseInt(k))\n\t\t.sort((a: number, b: number) => a - b);\n}\n\n/**\n * Checks if the provided amount is in the keyset.\n * @param amount amount to check\n * @param keyset to search in\n * @returns true if the amount is in the keyset, false otherwise\n */\nexport function hasCorrespondingKey(amount: number, keyset: Keys): boolean {\n\treturn amount in keyset;\n}\n\n/**\n * Converts a bytes array to a number.\n * @param bytes to convert to number\n * @returns  number\n */\nexport function bytesToNumber(bytes: Uint8Array): bigint {\n\treturn hexToNumber(bytesToHex(bytes));\n}\n\n/**\n * Converts a hex string to a number.\n * @param hex to convert to number\n * @returns number\n */\nexport function hexToNumber(hex: string): bigint {\n\treturn BigInt(`0x${hex}`);\n}\n\n/**\n * Converts a number to a hex string of 64 characters.\n * @param number (bigint) to conver to hex\n * @returns hex string start-padded to 64 characters\n */\nexport function numberToHexPadded64(number: bigint): string {\n\treturn number.toString(16).padStart(64, '0');\n}\n\nfunction isValidHex(str: string) {\n\treturn /^[a-f0-9]*$/i.test(str);\n}\n\n/**\n * Checks wether a proof or a list of proofs contains a non-hex id\n * @param p Proof or list of proofs\n * @returns boolean\n */\nexport function hasNonHexId(p: Proof | Array<Proof>) {\n\tif (Array.isArray(p)) {\n\t\treturn p.some((proof) => !isValidHex(proof.id));\n\t}\n\treturn isValidHex(p.id);\n}\n\n//used for json serialization\nexport function bigIntStringify<T>(_key: unknown, value: T) {\n\treturn typeof value === 'bigint' ? value.toString() : value;\n}\n\n/**\n * Helper function to encode a v3 cashu token\n * @param token to encode\n * @returns encoded token\n */\nexport function getEncodedTokenV3(token: Token): string {\n\tconst v3TokenObj: DeprecatedToken = { token: [{ mint: token.mint, proofs: token.proofs }] };\n\tif (token.unit) {\n\t\tv3TokenObj.unit = token.unit;\n\t}\n\tif (token.memo) {\n\t\tv3TokenObj.memo = token.memo;\n\t}\n\treturn TOKEN_PREFIX + TOKEN_VERSION + encodeJsonToBase64(v3TokenObj);\n}\n\n/**\n * Helper function to encode a cashu token (defaults to v4 if keyset id allows it)\n * @param token\n * @param [opts]\n */\nexport function getEncodedToken(token: Token, opts?: { version: 3 | 4 }): string {\n\tconst nonHex = hasNonHexId(token.proofs);\n\tif (nonHex || opts?.version === 3) {\n\t\tif (opts?.version === 4) {\n\t\t\tthrow new Error('can not encode to v4 token if proofs contain non-hex keyset id');\n\t\t}\n\t\treturn getEncodedTokenV3(token);\n\t}\n\treturn getEncodedTokenV4(token);\n}\n\nexport function getEncodedTokenV4(token: Token): string {\n\t// Make sure each DLEQ has its blinding factor\n\ttoken.proofs.forEach((p) => {\n\t\tif (p.dleq && p.dleq.r == undefined) {\n\t\t\tthrow new Error('Missing blinding factor in included DLEQ proof');\n\t\t}\n\t});\n\tconst nonHex = hasNonHexId(token.proofs);\n\tif (nonHex) {\n\t\tthrow new Error('can not encode to v4 token if proofs contain non-hex keyset id');\n\t}\n\n\tconst tokenTemplate = templateFromToken(token);\n\n\tconst encodedData = encodeCBOR(tokenTemplate);\n\tconst prefix = 'cashu';\n\tconst version = 'B';\n\tconst base64Data = encodeUint8toBase64Url(encodedData);\n\treturn prefix + version + base64Data;\n}\n\nfunction templateFromToken(token: Token): TokenV4Template {\n\tconst idMap: { [id: string]: Array<Proof> } = {};\n\tconst mint = token.mint;\n\tfor (let i = 0; i < token.proofs.length; i++) {\n\t\tconst proof = token.proofs[i];\n\t\tif (idMap[proof.id]) {\n\t\t\tidMap[proof.id].push(proof);\n\t\t} else {\n\t\t\tidMap[proof.id] = [proof];\n\t\t}\n\t}\n\tconst tokenTemplate: TokenV4Template = {\n\t\tm: mint,\n\t\tu: token.unit || 'sat',\n\t\tt: Object.keys(idMap).map(\n\t\t\t(id: string): V4InnerToken => ({\n\t\t\t\ti: hexToBytes(id),\n\t\t\t\tp: idMap[id].map(\n\t\t\t\t\t(p: Proof): V4ProofTemplate => ({\n\t\t\t\t\t\ta: p.amount,\n\t\t\t\t\t\ts: p.secret,\n\t\t\t\t\t\tc: hexToBytes(p.C),\n\t\t\t\t\t\t...(p.dleq && {\n\t\t\t\t\t\t\td: {\n\t\t\t\t\t\t\t\te: hexToBytes(p.dleq.e),\n\t\t\t\t\t\t\t\ts: hexToBytes(p.dleq.s),\n\t\t\t\t\t\t\t\tr: hexToBytes(p.dleq.r ?? '00')\n\t\t\t\t\t\t\t} as V4DLEQTemplate\n\t\t\t\t\t\t}),\n\t\t\t\t\t\t...(p.witness && {\n\t\t\t\t\t\t\tw: JSON.stringify(p.witness)\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t})\n\t\t)\n\t} as TokenV4Template;\n\tif (token.memo) {\n\t\ttokenTemplate.d = token.memo;\n\t}\n\treturn tokenTemplate;\n}\n\nfunction tokenFromTemplate(template: TokenV4Template): Token {\n\tconst proofs: Array<Proof> = [];\n\ttemplate.t.forEach((t) =>\n\t\tt.p.forEach((p) => {\n\t\t\tproofs.push({\n\t\t\t\tsecret: p.s,\n\t\t\t\tC: bytesToHex(p.c),\n\t\t\t\tamount: p.a,\n\t\t\t\tid: bytesToHex(t.i),\n\t\t\t\t...(p.d && {\n\t\t\t\t\tdleq: {\n\t\t\t\t\t\tr: bytesToHex(p.d.r),\n\t\t\t\t\t\ts: bytesToHex(p.d.s),\n\t\t\t\t\t\te: bytesToHex(p.d.e)\n\t\t\t\t\t} as SerializedDLEQ\n\t\t\t\t}),\n\t\t\t\t...(p.w && {\n\t\t\t\t\twitness: p.w\n\t\t\t\t})\n\t\t\t});\n\t\t})\n\t);\n\tconst decodedToken: Token = { mint: template.m, proofs, unit: template.u || 'sat' };\n\tif (template.d) {\n\t\tdecodedToken.memo = template.d;\n\t}\n\treturn decodedToken;\n}\n\n/**\n * Helper function to decode cashu tokens into object\n * @param token an encoded cashu token (cashuAey...)\n * @returns cashu token object\n */\nexport function getDecodedToken(token: string) {\n\t// remove prefixes\n\tconst uriPrefixes = ['web+cashu://', 'cashu://', 'cashu:', 'cashu'];\n\turiPrefixes.forEach((prefix: string) => {\n\t\tif (!token.startsWith(prefix)) {\n\t\t\treturn;\n\t\t}\n\t\ttoken = token.slice(prefix.length);\n\t});\n\treturn handleTokens(token);\n}\n\n/**\n * Helper function to decode different versions of cashu tokens into an object\n * @param token an encoded cashu token (cashuAey...)\n * @returns cashu Token object\n */\nexport function handleTokens(token: string): Token {\n\tconst version = token.slice(0, 1);\n\tconst encodedToken = token.slice(1);\n\tif (version === 'A') {\n\t\tconst parsedV3Token = encodeBase64ToJson<DeprecatedToken>(encodedToken);\n\t\tif (parsedV3Token.token.length > 1) {\n\t\t\tthrow new Error('Multi entry token are not supported');\n\t\t}\n\t\tconst entry = parsedV3Token.token[0];\n\t\tconst tokenObj: Token = {\n\t\t\tmint: entry.mint,\n\t\t\tproofs: entry.proofs,\n\t\t\tunit: parsedV3Token.unit || 'sat'\n\t\t};\n\t\tif (parsedV3Token.memo) {\n\t\t\ttokenObj.memo = parsedV3Token.memo;\n\t\t}\n\t\treturn tokenObj;\n\t} else if (version === 'B') {\n\t\tconst uInt8Token = encodeBase64toUint8(encodedToken);\n\t\tconst tokenData = decodeCBOR(uInt8Token) as TokenV4Template;\n\t\tconst decodedToken = tokenFromTemplate(tokenData);\n\t\treturn decodedToken;\n\t}\n\tthrow new Error('Token version is not supported');\n}\n/**\n * Returns the keyset id of a set of keys\n * @param keys keys object to derive keyset id from\n * @returns\n */\nexport function deriveKeysetId(keys: Keys) {\n\tconst pubkeysConcat = Object.entries(keys)\n\t\t.sort((a: [string, string], b: [string, string]) => +a[0] - +b[0])\n\t\t.map(([, pubKey]: [unknown, string]) => hexToBytes(pubKey))\n\t\t.reduce((prev: Uint8Array, curr: Uint8Array) => mergeUInt8Arrays(prev, curr), new Uint8Array());\n\tconst hash = sha256(pubkeysConcat);\n\tconst hashHex = Buffer.from(hash).toString('hex').slice(0, 14);\n\treturn '00' + hashHex;\n}\n\nexport function mergeUInt8Arrays(a1: Uint8Array, a2: Uint8Array): Uint8Array {\n\t// sum of individual array lengths\n\tconst mergedArray = new Uint8Array(a1.length + a2.length);\n\tmergedArray.set(a1);\n\tmergedArray.set(a2, a1.length);\n\treturn mergedArray;\n}\n\nexport function sortProofsById(proofs: Array<Proof>) {\n\treturn proofs.sort((a: Proof, b: Proof) => a.id.localeCompare(b.id));\n}\n\nexport function isObj(v: unknown): v is object {\n\treturn typeof v === 'object';\n}\n\nexport function checkResponse(data: { error?: string; detail?: string }) {\n\tif (!isObj(data)) return;\n\tif ('error' in data && data.error) {\n\t\tthrow new Error(data.error);\n\t}\n\tif ('detail' in data && data.detail) {\n\t\tthrow new Error(data.detail);\n\t}\n}\n\nexport function joinUrls(...parts: Array<string>): string {\n\treturn parts.map((part: string) => part.replace(/(^\\/+|\\/+$)/g, '')).join('/');\n}\n\nexport function sanitizeUrl(url: string): string {\n\treturn url.replace(/\\/$/, '');\n}\n\nexport function sumProofs(proofs: Array<Proof>) {\n\treturn proofs.reduce((acc: number, proof: Proof) => acc + proof.amount, 0);\n}\n\nexport function decodePaymentRequest(paymentRequest: string) {\n\treturn PaymentRequest.fromEncodedRequest(paymentRequest);\n}\n\nexport class MessageNode {\n\tprivate _value: string;\n\tprivate _next: MessageNode | null;\n\n\tpublic get value(): string {\n\t\treturn this._value;\n\t}\n\tpublic set value(message: string) {\n\t\tthis._value = message;\n\t}\n\tpublic get next(): MessageNode | null {\n\t\treturn this._next;\n\t}\n\tpublic set next(node: MessageNode | null) {\n\t\tthis._next = node;\n\t}\n\n\tconstructor(message: string) {\n\t\tthis._value = message;\n\t\tthis._next = null;\n\t}\n}\n\nexport class MessageQueue {\n\tprivate _first: MessageNode | null;\n\tprivate _last: MessageNode | null;\n\n\tpublic get first(): MessageNode | null {\n\t\treturn this._first;\n\t}\n\tpublic set first(messageNode: MessageNode | null) {\n\t\tthis._first = messageNode;\n\t}\n\tpublic get last(): MessageNode | null {\n\t\treturn this._last;\n\t}\n\tpublic set last(messageNode: MessageNode | null) {\n\t\tthis._last = messageNode;\n\t}\n\tprivate _size: number;\n\tpublic get size(): number {\n\t\treturn this._size;\n\t}\n\tpublic set size(v: number) {\n\t\tthis._size = v;\n\t}\n\n\tconstructor() {\n\t\tthis._first = null;\n\t\tthis._last = null;\n\t\tthis._size = 0;\n\t}\n\tenqueue(message: string): boolean {\n\t\tconst newNode = new MessageNode(message);\n\t\tif (this._size === 0 || !this._last) {\n\t\t\tthis._first = newNode;\n\t\t\tthis._last = newNode;\n\t\t} else {\n\t\t\tthis._last.next = newNode;\n\t\t\tthis._last = newNode;\n\t\t}\n\t\tthis._size++;\n\t\treturn true;\n\t}\n\tdequeue(): string | null {\n\t\tif (this._size === 0 || !this._first) return null;\n\n\t\tconst prev = this._first;\n\t\tthis._first = prev.next;\n\t\tprev.next = null;\n\n\t\tthis._size--;\n\t\treturn prev.value;\n\t}\n}\n/**\n * Removes all traces of DLEQs from a list of proofs\n * @param proofs The list of proofs that dleq should be stripped from\n */\nexport function stripDleq(proofs: Array<Proof>): Array<Omit<Proof, 'dleq'>> {\n\treturn proofs.map((p) => {\n\t\tconst newP = { ...p };\n\t\tdelete newP['dleq'];\n\t\treturn newP;\n\t});\n}\n\n/**\n * Checks that the proof has a valid DLEQ proof according to\n * keyset `keys`\n * @param proof The proof subject to verification\n * @param keyset The Mint's keyset to be used for verification\n * @returns true if verification succeeded, false otherwise\n * @throws Error if @param proof does not match any key in @param keyset\n */\nexport function hasValidDleq(proof: Proof, keyset: MintKeys): boolean {\n\tif (proof.dleq == undefined) {\n\t\treturn false;\n\t}\n\tconst dleq = {\n\t\te: hexToBytes(proof.dleq.e),\n\t\ts: hexToBytes(proof.dleq.s),\n\t\tr: hexToNumber(proof.dleq.r ?? '00')\n\t} as DLEQ;\n\tif (!hasCorrespondingKey(proof.amount, keyset.keys)) {\n\t\tthrow new Error(`undefined key for amount ${proof.amount}`);\n\t}\n\tconst key = keyset.keys[proof.amount];\n\tif (\n\t\t!verifyDLEQProof_reblind(\n\t\t\tnew TextEncoder().encode(proof.secret),\n\t\t\tdleq,\n\t\t\tpointFromHex(proof.C),\n\t\t\tpointFromHex(key)\n\t\t)\n\t) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/**\n * Helper function to encode a cashu auth token authA\n * @param proof\n */\nexport function getEncodedAuthToken(proof: Proof): string {\n\tconst token = {\n\t\tid: proof.id,\n\t\tsecret: proof.secret,\n\t\tC: proof.C\n\t};\n\tconst base64Data = encodeJsonToBase64(token);\n\tconst prefix = 'auth';\n\tconst version = 'A';\n\treturn prefix + version + base64Data;\n}\n\nfunction concatByteArrays(...arrays: Array<Uint8Array>): Uint8Array {\n\tconst totalLength = arrays.reduce((a, c) => a + c.length, 0);\n\tconst byteArray = new Uint8Array(totalLength);\n\tlet pointer = 0;\n\tfor (let i = 0; i < arrays.length; i++) {\n\t\tbyteArray.set(arrays[i], pointer);\n\t\tpointer = pointer + arrays[i].length;\n\t}\n\treturn byteArray;\n}\n\nexport function getEncodedTokenBinary(token: Token): Uint8Array {\n\tconst utf8Encoder = new TextEncoder();\n\tconst template = templateFromToken(token);\n\tconst binaryTemplate = encodeCBOR(template);\n\tconst prefix = utf8Encoder.encode('craw');\n\tconst version = utf8Encoder.encode('B');\n\treturn concatByteArrays(prefix, version, binaryTemplate);\n}\n\nexport function getDecodedTokenBinary(bytes: Uint8Array): Token {\n\tconst utfDecoder = new TextDecoder();\n\tconst prefix = utfDecoder.decode(bytes.slice(0, 4));\n\tconst version = utfDecoder.decode(new Uint8Array([bytes[4]]));\n\tif (prefix !== 'craw' || version !== 'B') {\n\t\tthrow new Error('not a valid binary token');\n\t}\n\tconst binaryToken = bytes.slice(5);\n\tconst decoded = decodeCBOR(binaryToken) as TokenV4Template;\n\treturn tokenFromTemplate(decoded);\n}\n\nfunction sumArray(arr: Array<number>) {\n\treturn arr.reduce((a, c) => a + c, 0);\n}\n","let _WS: typeof WebSocket;\n\nif (typeof WebSocket !== 'undefined') {\n\t_WS = WebSocket;\n}\n\nexport function injectWebSocketImpl(ws: any) {\n\t_WS = ws;\n}\n\nexport function getWebSocketImpl() {\n\treturn _WS;\n}\n","import { MessageQueue } from './utils';\nimport {\n\tJsonRpcErrorObject,\n\tJsonRpcMessage,\n\tJsonRpcNotification,\n\tJsonRpcReqParams,\n\tRpcSubId\n} from './model/types';\nimport { OnOpenError, OnOpenSuccess } from './model/types/wallet/websocket';\nimport { getWebSocketImpl } from './ws';\n\nexport class ConnectionManager {\n\tstatic instace: ConnectionManager;\n\tprivate connectionMap: Map<string, WSConnection> = new Map();\n\n\tstatic getInstance() {\n\t\tif (!ConnectionManager.instace) {\n\t\t\tConnectionManager.instace = new ConnectionManager();\n\t\t}\n\t\treturn ConnectionManager.instace;\n\t}\n\n\tgetConnection(url: string): WSConnection {\n\t\tif (this.connectionMap.has(url)) {\n\t\t\treturn this.connectionMap.get(url) as WSConnection;\n\t\t}\n\t\tconst newConn = new WSConnection(url);\n\t\tthis.connectionMap.set(url, newConn);\n\t\treturn newConn;\n\t}\n}\n\nexport class WSConnection {\n\tpublic readonly url: URL;\n\tprivate readonly _WS: typeof WebSocket;\n\tprivate ws: WebSocket | undefined;\n\tprivate connectionPromise: Promise<void> | undefined;\n\tprivate subListeners: { [subId: string]: Array<(payload: any) => any> } = {};\n\tprivate rpcListeners: { [rpcSubId: string]: any } = {};\n\tprivate messageQueue: MessageQueue;\n\tprivate handlingInterval?: number;\n\tprivate rpcId = 0;\n\n\tconstructor(url: string) {\n\t\tthis._WS = getWebSocketImpl();\n\t\tthis.url = new URL(url);\n\t\tthis.messageQueue = new MessageQueue();\n\t}\n\n\tconnect() {\n\t\tif (!this.connectionPromise) {\n\t\t\tthis.connectionPromise = new Promise((res: OnOpenSuccess, rej: OnOpenError) => {\n\t\t\t\ttry {\n\t\t\t\t\tthis.ws = new this._WS(this.url.toString());\n\t\t\t\t} catch (err) {\n\t\t\t\t\trej(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.ws.onopen = () => {\n\t\t\t\t\tres();\n\t\t\t\t};\n\t\t\t\tthis.ws.onerror = () => {\n\t\t\t\t\trej(new Error('Failed to open WebSocket'));\n\t\t\t\t};\n\t\t\t\tthis.ws.onmessage = (e: MessageEvent) => {\n\t\t\t\t\tthis.messageQueue.enqueue(e.data);\n\t\t\t\t\tif (!this.handlingInterval) {\n\t\t\t\t\t\tthis.handlingInterval = setInterval(\n\t\t\t\t\t\t\tthis.handleNextMesage.bind(this),\n\t\t\t\t\t\t\t0\n\t\t\t\t\t\t) as unknown as number;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tthis.ws.onclose = () => {\n\t\t\t\t\tthis.connectionPromise = undefined;\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\t\treturn this.connectionPromise;\n\t}\n\n\tsendRequest(method: 'subscribe', params: JsonRpcReqParams): void;\n\tsendRequest(method: 'unsubscribe', params: { subId: string }): void;\n\tsendRequest(method: 'subscribe' | 'unsubscribe', params: Partial<JsonRpcReqParams>) {\n\t\tif (this.ws?.readyState !== 1) {\n\t\t\tthrow new Error('Socket not open...');\n\t\t}\n\t\tconst id = this.rpcId;\n\t\tthis.rpcId++;\n\t\tconst message = JSON.stringify({ jsonrpc: '2.0', method, params, id });\n\t\tthis.ws?.send(message);\n\t}\n\n\tcloseSubscription(subId: string) {\n\t\tthis.ws?.send(JSON.stringify(['CLOSE', subId]));\n\t}\n\n\taddSubListener(subId: string, callback: (payload: any) => any) {\n\t\t(this.subListeners[subId] = this.subListeners[subId] || []).push(callback);\n\t}\n\n\t//TODO: Move to RPCManagerClass\n\tprivate addRpcListener(\n\t\tcallback: () => any,\n\t\terrorCallback: (e: JsonRpcErrorObject) => any,\n\t\tid: Exclude<RpcSubId, null>\n\t) {\n\t\tthis.rpcListeners[id] = { callback, errorCallback };\n\t}\n\n\t//TODO: Move to RPCManagerClass\n\tprivate removeRpcListener(id: Exclude<RpcSubId, null>) {\n\t\tdelete this.rpcListeners[id];\n\t}\n\n\tprivate removeListener(subId: string, callback: (payload: any) => any) {\n\t\tif (!this.subListeners[subId]) {\n\t\t\treturn;\n\t\t}\n\t\tif (this.subListeners[subId].length === 1) {\n\t\t\tdelete this.subListeners[subId];\n\t\t\treturn;\n\t\t}\n\t\tthis.subListeners[subId] = this.subListeners[subId].filter((fn: any) => fn !== callback);\n\t}\n\n\tasync ensureConnection() {\n\t\tif (this.ws?.readyState !== 1) {\n\t\t\tawait this.connect();\n\t\t}\n\t}\n\n\tprivate handleNextMesage() {\n\t\tif (this.messageQueue.size === 0) {\n\t\t\tclearInterval(this.handlingInterval);\n\t\t\tthis.handlingInterval = undefined;\n\t\t\treturn;\n\t\t}\n\t\tconst message = this.messageQueue.dequeue() as string;\n\t\tlet parsed;\n\t\ttry {\n\t\t\tparsed = JSON.parse(message) as JsonRpcMessage;\n\t\t\tif ('result' in parsed && parsed.id != undefined) {\n\t\t\t\tif (this.rpcListeners[parsed.id]) {\n\t\t\t\t\tthis.rpcListeners[parsed.id].callback();\n\t\t\t\t\tthis.removeRpcListener(parsed.id);\n\t\t\t\t}\n\t\t\t} else if ('error' in parsed && parsed.id != undefined) {\n\t\t\t\tif (this.rpcListeners[parsed.id]) {\n\t\t\t\t\tthis.rpcListeners[parsed.id].errorCallback(parsed.error);\n\t\t\t\t\tthis.removeRpcListener(parsed.id);\n\t\t\t\t}\n\t\t\t} else if ('method' in parsed) {\n\t\t\t\tif ('id' in parsed) {\n\t\t\t\t\t// Do nothing as mints should not send requests\n\t\t\t\t} else {\n\t\t\t\t\tconst subId = parsed.params.subId;\n\t\t\t\t\tif (!subId) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (this.subListeners[subId]?.length > 0) {\n\t\t\t\t\t\tconst notification = parsed as JsonRpcNotification;\n\t\t\t\t\t\tthis.subListeners[subId].forEach((cb) => cb(notification.params.payload));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(e);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tcreateSubscription(\n\t\tparams: Omit<JsonRpcReqParams, 'subId'>,\n\t\tcallback: (payload: any) => any,\n\t\terrorCallback: (e: Error) => any\n\t) {\n\t\tif (this.ws?.readyState !== 1) {\n\t\t\treturn errorCallback(new Error('Socket is not open'));\n\t\t}\n\t\tconst subId = (Math.random() + 1).toString(36).substring(7);\n\t\tthis.addRpcListener(\n\t\t\t() => {\n\t\t\t\tthis.addSubListener(subId, callback);\n\t\t\t},\n\t\t\t(e: JsonRpcErrorObject) => {\n\t\t\t\terrorCallback(new Error(e.message));\n\t\t\t},\n\t\t\tthis.rpcId\n\t\t);\n\t\tthis.sendRequest('subscribe', { ...params, subId });\n\t\tthis.rpcId++;\n\t\treturn subId;\n\t}\n\n\tcancelSubscription(subId: string, callback: (payload: any) => any) {\n\t\tthis.removeRpcListener(subId);\n\t\tthis.removeListener(subId, callback);\n\t\tthis.rpcId++;\n\t\tthis.sendRequest('unsubscribe', { subId });\n\t}\n\n\tget activeSubscriptions() {\n\t\treturn Object.keys(this.subListeners);\n\t}\n\n\tclose() {\n\t\tif (this.ws) {\n\t\t\tthis.ws?.close();\n\t\t}\n\t}\n}\n","import { SerializedBlindedMessage } from '../wallet';\n\n/**\n * Cashu api error\n */\nexport type ApiError = {\n\t/**\n\t * Error message\n\t */\n\terror?: string;\n\t/**\n\t * HTTP error code\n\t */\n\tcode?: number;\n\t/**\n\t * Detailed error message\n\t */\n\tdetail?: string;\n};\n\n/**\n * Entries of CheckStateResponse with state of the proof\n */\nexport type ProofState = {\n\tY: string;\n\tstate: CheckStateEnum;\n\twitness: string | null;\n};\n\n/**\n * Enum for the state of a proof\n */\nexport const CheckStateEnum = {\n\tUNSPENT: 'UNSPENT',\n\tPENDING: 'PENDING',\n\tSPENT: 'SPENT'\n} as const;\nexport type CheckStateEnum = (typeof CheckStateEnum)[keyof typeof CheckStateEnum];\n\n/**\n * Response when checking proofs if they are spendable. Should not rely on this for receiving, since it can be easily cheated.\n */\nexport type CheckStateResponse = {\n\t/**\n\t *\n\t */\n\tstates: Array<ProofState>;\n} & ApiError;\n\n/**\n * Response from mint at /info endpoint\n */\nexport type GetInfoResponse = {\n\tname: string;\n\tpubkey: string;\n\tversion: string;\n\tdescription?: string;\n\tdescription_long?: string;\n\ticon_url?: string;\n\tcontact: Array<MintContactInfo>;\n\tnuts: {\n\t\t'4': {\n\t\t\t// Minting\n\t\t\tmethods: Array<SwapMethod>;\n\t\t\tdisabled: boolean;\n\t\t};\n\t\t'5': {\n\t\t\t// Melting\n\t\t\tmethods: Array<SwapMethod>;\n\t\t\tdisabled: boolean;\n\t\t};\n\t\t'7'?: {\n\t\t\t// Token state check\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'8'?: {\n\t\t\t// Overpaid melt fees\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'9'?: {\n\t\t\t// Restore\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'10'?: {\n\t\t\t// Spending conditions\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'11'?: {\n\t\t\t// P2PK\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'12'?: {\n\t\t\t// DLEQ\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'14'?: {\n\t\t\t// HTLCs\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'15'?: {\n\t\t\t// MPP\n\t\t\tmethods: Array<MPPMethod>;\n\t\t};\n\t\t'17'?: {\n\t\t\t// WebSockets\n\t\t\tsupported: Array<WebSocketSupport>;\n\t\t};\n\t\t'20'?: {\n\t\t\t// Locked Mint Quote\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'22'?: {\n\t\t\t// Blind Authentication\n\t\t\tbat_max_mint: number;\n\t\t\tprotected_endpoints: Array<{ method: 'GET' | 'POST'; path: string }>;\n\t\t};\n\t};\n\tmotd?: string;\n};\n\n/**\n * Response from the mint after requesting a melt quote\n */\nexport type PartialMeltQuoteResponse = {\n\t/**\n\t * Quote ID\n\t */\n\tquote: string;\n\t/**\n\t * Amount to be melted\n\t */\n\tamount: number;\n\t/**\n\t * Fee reserve to be added to the amount\n\t */\n\tfee_reserve: number;\n\t/**\n\t * State of the melt quote\n\t */\n\tstate: MeltQuoteState;\n\t/**\n\t * Timestamp of when the quote expires\n\t */\n\texpiry: number;\n\t/**\n\t * preimage of the paid invoice. is null if it the invoice has not been paid yet. can be null, depending on which LN-backend the mint uses\n\t */\n\tpayment_preimage: string | null;\n\t/**\n\t * Return/Change from overpaid fees. This happens due to Lighting fee estimation being inaccurate\n\t */\n\tchange?: Array<SerializedBlindedSignature>;\n\t/**\n\t *  Payment request for the melt quote.\n\t */\n\trequest?: string;\n\t/**\n\t *  Unit of the melt quote.\n\t */\n\tunit?: string;\n} & ApiError;\n\nexport type MeltQuoteResponse = PartialMeltQuoteResponse & { request: string; unit: string };\n\nexport const MeltQuoteState = {\n\tUNPAID: 'UNPAID',\n\tPENDING: 'PENDING',\n\tPAID: 'PAID'\n} as const;\nexport type MeltQuoteState = (typeof MeltQuoteState)[keyof typeof MeltQuoteState];\n\nexport type MintContactInfo = {\n\tmethod: string;\n\tinfo: string;\n};\n\nexport const MintQuoteState = {\n\tUNPAID: 'UNPAID',\n\tPAID: 'PAID',\n\tISSUED: 'ISSUED'\n} as const;\nexport type MintQuoteState = (typeof MintQuoteState)[keyof typeof MintQuoteState];\n\n/**\n * Response from the mint after requesting a mint\n */\nexport type PartialMintQuoteResponse = {\n\t/**\n\t * Payment request\n\t */\n\trequest: string;\n\t/**\n\t * Quote ID\n\t */\n\tquote: string;\n\t/**\n\t * State of the mint quote\n\t */\n\tstate: MintQuoteState;\n\t/**\n\t * Timestamp of when the quote expires\n\t */\n\texpiry: number;\n\t/**\n\t * Public key the quote is locked to\n\t */\n\tpubkey?: string;\n\t/**\n\t * Unit of the quote\n\t */\n\tunit?: string;\n\t/**\n\t * Amount requested for mint quote\n\t */\n\tamount?: number;\n} & ApiError;\n\nexport type MintQuoteResponse = PartialMintQuoteResponse & { amount: number; unit: string };\n\nexport type LockedMintQuoteResponse = MintQuoteResponse & { pubkey: string };\n\n/**\n * Response from the mint after requesting a mint\n */\nexport type MintResponse = {\n\tsignatures: Array<SerializedBlindedSignature>;\n} & ApiError;\n\n/**\n * Response from mint at /v1/restore endpoint\n */\nexport type PostRestoreResponse = {\n\toutputs: Array<SerializedBlindedMessage>;\n\tsignatures: Array<SerializedBlindedSignature>;\n};\n\n/*\n * Zero-Knowledge that BlindedSignature\n * was generated using a specific public key\n */\nexport type SerializedDLEQ = {\n\ts: string;\n\te: string;\n\tr?: string;\n};\n\n/**\n * Blinded signature as it is received from the mint\n */\nexport type SerializedBlindedSignature = {\n\t/**\n\t * keyset id for indicating which public key was used to sign the blinded message\n\t */\n\tid: string;\n\t/**\n\t * Amount denominated in Satoshi\n\t */\n\tamount: number;\n\t/**\n\t * Blinded signature\n\t */\n\tC_: string;\n\t/**\n\t * DLEQ Proof\n\t */\n\tdleq?: SerializedDLEQ;\n};\n\n/**\n * Ecash to other MoE swap method, displayed in @type {GetInfoResponse}\n */\nexport type SwapMethod = {\n\tmethod: string;\n\tunit: string;\n\tmin_amount: number;\n\tmax_amount: number;\n};\n\n/**\n * Response from the mint after performing a split action\n */\nexport type SwapResponse = {\n\t/**\n\t * represents the outputs after the split\n\t */\n\tsignatures: Array<SerializedBlindedSignature>;\n} & ApiError;\n\n/**\n * MPP supported methods\n */\nexport type MPPMethod = {\n\tmethod: string;\n\tunit: string;\n};\n\n/**\n * WebSocket supported methods\n */\nexport type WebSocketSupport = {\n\tmethod: string;\n\tunit: string;\n\tcommands: Array<string>;\n};\n\n/**\n * Response from the mint after blind auth minting\n */\nexport type BlindAuthMintResponse = {\n\tsignatures: Array<SerializedBlindedSignature>;\n} & ApiError;\n","import { Proof } from './index';\n\nexport type RawTransport = {\n\tt: PaymentRequestTransportType; // type\n\ta: string; // target\n\tg?: Array<Array<string>>; // tags\n};\n\nexport type RawNUT10Option = {\n\tk: string; // kind\n\td: string; // data\n\tt: Array<Array<string>>; // tags\n};\n\nexport type RawPaymentRequest = {\n\ti?: string; // id\n\ta?: number; // amount\n\tu?: string; // unit\n\ts?: boolean; // single use\n\tm?: Array<string>; // mints\n\td?: string; // description\n\tt?: Array<RawTransport>; // transports\n\tnut10?: RawNUT10Option;\n};\n\nexport type PaymentRequestTransport = {\n\ttype: PaymentRequestTransportType;\n\ttarget: string;\n\ttags?: Array<Array<string>>;\n};\n\nexport enum PaymentRequestTransportType {\n\tPOST = 'post',\n\tNOSTR = 'nostr'\n}\n\nexport type PaymentRequestPayload = {\n\tid?: string;\n\tmemo?: string;\n\tunit: string;\n\tmint: string;\n\tproofs: Array<Proof>;\n};\n\n/** Used to express a spending condition that proofs should be encumbered with */\nexport type NUT10Option = {\n\t/** The kind of spending condition */\n\tkind: string;\n\t/** Expresses the spending condition relative to the kind */\n\tdata: string;\n\t/** Tags associated with the spending condition for additional data */\n\ttags: Array<Array<string>>;\n};\n","/** This error is thrown when a HTTP response is not 2XX nor a protocol error. */\nexport class HttpResponseError extends Error {\n\tstatus: number;\n\tconstructor(message: string, status: number) {\n\t\tsuper(message);\n\t\tthis.status = status;\n\t\tthis.name = 'HttpResponseError';\n\t\tObject.setPrototypeOf(this, HttpResponseError.prototype);\n\t}\n}\n\n/** This error is thrown when a network request fails. */\nexport class NetworkError extends Error {\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = 'NetworkError';\n\t\tObject.setPrototypeOf(this, NetworkError.prototype);\n\t}\n}\n\n/**\n * This error is thrown when a [protocol error](https://github.com/cashubtc/nuts/blob/main/00.md#errors) occurs.\n * See error codes [here](https://github.com/cashubtc/nuts/blob/main/error_codes.md).\n */\nexport class MintOperationError extends HttpResponseError {\n\tcode: number;\n\tconstructor(code: number, detail: string) {\n\t\tsuper(detail || 'Unknown mint operation error', 400);\n\t\tthis.code = code;\n\t\tthis.name = 'MintOperationError';\n\t\tObject.setPrototypeOf(this, MintOperationError.prototype);\n\t}\n}\n","import { HttpResponseError, NetworkError, MintOperationError } from './model/Errors';\n\ntype RequestArgs = {\n\tendpoint: string;\n\trequestBody?: Record<string, unknown>;\n\theaders?: Record<string, string>;\n};\n\ntype RequestOptions = RequestArgs & Omit<RequestInit, 'body' | 'headers'>;\n\nlet globalRequestOptions: Partial<RequestOptions> = {};\n\n/**\n * An object containing any custom settings that you want to apply to the global fetch method.\n * @param options See possible options here: https://developer.mozilla.org/en-US/docs/Web/API/fetch#options\n */\nexport function setGlobalRequestOptions(options: Partial<RequestOptions>): void {\n\tglobalRequestOptions = options;\n}\n\nasync function _request({\n\tendpoint,\n\trequestBody,\n\theaders: requestHeaders,\n\t...options\n}: RequestOptions): Promise<unknown> {\n\tconst body = requestBody ? JSON.stringify(requestBody) : undefined;\n\tconst headers = {\n\t\t...{ Accept: 'application/json, text/plain, */*' },\n\t\t...(body ? { 'Content-Type': 'application/json' } : undefined),\n\t\t...requestHeaders\n\t};\n\n\tlet response: Response;\n\ttry {\n\t\tresponse = await fetch(endpoint, { body, headers, ...options });\n\t} catch (err) {\n\t\t// A fetch() promise only rejects when the request fails,\n\t\t// for example, because of a badly-formed request URL or a network error.\n\t\tthrow new NetworkError(err instanceof Error ? err.message : 'Network request failed');\n\t}\n\n\tif (!response.ok) {\n\t\tconst errorData = await response.json().catch(() => ({ error: 'bad response' }));\n\n\t\tif (response.status === 400 && 'code' in errorData && 'detail' in errorData) {\n\t\t\tthrow new MintOperationError(errorData.code, errorData.detail);\n\t\t}\n\n\t\tthrow new HttpResponseError(\n\t\t\t'error' in errorData ? errorData.error : errorData.detail || 'HTTP request failed',\n\t\t\tresponse.status\n\t\t);\n\t}\n\n\ttry {\n\t\treturn await response.json();\n\t} catch (err) {\n\t\tconsole.error('Failed to parse HTTP response', err);\n\t\tthrow new HttpResponseError('bad response', response.status);\n\t}\n}\n\nexport default async function request<T>(options: RequestOptions): Promise<T> {\n\tconst data = await _request({ ...options, ...globalRequestOptions });\n\treturn data as T;\n}\n","import type { PartialMeltQuoteResponse } from '../model/types/index.js';\nimport { MeltQuoteState } from '../model/types/index.js';\n\nexport type MeltQuoteResponsePaidDeprecated = {\n\tpaid?: boolean;\n};\n\nexport function handleMeltQuoteResponseDeprecated(\n\tresponse: PartialMeltQuoteResponse & MeltQuoteResponsePaidDeprecated\n): PartialMeltQuoteResponse {\n\t// if the response MeltQuoteResponse has a \"paid\" flag, we monkey patch it to the state enum\n\tif (!response.state) {\n\t\tconsole.warn(\n\t\t\t\"Field 'state' not found in MeltQuoteResponse. Update NUT-05 of mint: https://github.com/cashubtc/nuts/pull/136)\"\n\t\t);\n\t\tif (typeof response.paid === 'boolean') {\n\t\t\tresponse.state = response.paid ? MeltQuoteState.PAID : MeltQuoteState.UNPAID;\n\t\t}\n\t}\n\treturn response;\n}\n","import type { PartialMintQuoteResponse } from '../model/types/index.js';\nimport { MintQuoteState } from '../model/types/index.js';\n\nexport type MintQuoteResponsePaidDeprecated = {\n\tpaid?: boolean;\n};\n\nexport function handleMintQuoteResponseDeprecated(\n\tresponse: PartialMintQuoteResponse & MintQuoteResponsePaidDeprecated\n): PartialMintQuoteResponse {\n\t// if the response MeltQuoteResponse has a \"paid\" flag, we monkey patch it to the state enum\n\tif (!response.state) {\n\t\tconsole.warn(\n\t\t\t\"Field 'state' not found in MintQuoteResponse. Update NUT-04 of mint: https://github.com/cashubtc/nuts/pull/141)\"\n\t\t);\n\t\tif (typeof response.paid === 'boolean') {\n\t\t\tresponse.state = response.paid ? MintQuoteState.PAID : MintQuoteState.UNPAID;\n\t\t}\n\t}\n\treturn response;\n}\n","import type { MintContactInfo, GetInfoResponse } from '../model/types/index.js';\n\nexport function handleMintInfoContactFieldDeprecated(data: GetInfoResponse) {\n\t// Monkey patch old contact field [\"email\", \"me@mail.com\"] Array<[string, string]>; to new contact field [{method: \"email\", info: \"me@mail.com\"}] Array<MintContactInfo>\n\t// This is to maintain backwards compatibility with older versions of the mint\n\tif (Array.isArray(data?.contact) && data?.contact.length > 0) {\n\t\tdata.contact = data.contact.map((contact: MintContactInfo) => {\n\t\t\tif (\n\t\t\t\tArray.isArray(contact) &&\n\t\t\t\tcontact.length === 2 &&\n\t\t\t\ttypeof contact[0] === 'string' &&\n\t\t\t\ttypeof contact[1] === 'string'\n\t\t\t) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Mint returned deprecated 'contact' field: Update NUT-06: https://github.com/cashubtc/nuts/pull/117`\n\t\t\t\t);\n\t\t\t\treturn { method: contact[0], info: contact[1] } as MintContactInfo;\n\t\t\t}\n\t\t\treturn contact;\n\t\t});\n\t}\n\treturn data;\n}\n","import { GetInfoResponse, MPPMethod, SwapMethod, WebSocketSupport } from './types';\n\nexport class MintInfo {\n\tprivate readonly _mintInfo: GetInfoResponse;\n\tprivate readonly _protectedEnpoints?: {\n\t\tcache: {\n\t\t\t[url: string]: boolean;\n\t\t};\n\t\tapiReturn: Array<{ method: 'GET' | 'POST'; regex: RegExp; cachedValue?: boolean }>;\n\t};\n\n\tconstructor(info: GetInfoResponse) {\n\t\tthis._mintInfo = info;\n\t\tif (info.nuts[22]) {\n\t\t\tthis._protectedEnpoints = {\n\t\t\t\tcache: {},\n\t\t\t\tapiReturn: info.nuts[22].protected_endpoints.map((o) => ({\n\t\t\t\t\tmethod: o.method,\n\t\t\t\t\tregex: new RegExp(o.path)\n\t\t\t\t}))\n\t\t\t};\n\t\t}\n\t}\n\n\tisSupported(num: 4 | 5): { disabled: boolean; params: Array<SwapMethod> };\n\tisSupported(num: 7 | 8 | 9 | 10 | 11 | 12 | 14 | 20): { supported: boolean };\n\tisSupported(num: 17): { supported: boolean; params?: Array<WebSocketSupport> };\n\tisSupported(num: 15): { supported: boolean; params?: Array<MPPMethod> };\n\tisSupported(num: number) {\n\t\tswitch (num) {\n\t\t\tcase 4:\n\t\t\tcase 5: {\n\t\t\t\treturn this.checkMintMelt(num);\n\t\t\t}\n\t\t\tcase 7:\n\t\t\tcase 8:\n\t\t\tcase 9:\n\t\t\tcase 10:\n\t\t\tcase 11:\n\t\t\tcase 12:\n\t\t\tcase 14:\n\t\t\tcase 20: {\n\t\t\t\treturn this.checkGenericNut(num);\n\t\t\t}\n\t\t\tcase 17: {\n\t\t\t\treturn this.checkNut17();\n\t\t\t}\n\t\t\tcase 15: {\n\t\t\t\treturn this.checkNut15();\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new Error('nut is not supported by cashu-ts');\n\t\t\t}\n\t\t}\n\t}\n\n\trequiresBlindAuthToken(path: string) {\n\t\tif (!this._protectedEnpoints) {\n\t\t\treturn false;\n\t\t}\n\t\tif (typeof this._protectedEnpoints.cache[path] === 'boolean') {\n\t\t\treturn this._protectedEnpoints.cache[path];\n\t\t}\n\t\tconst isProtectedEndpoint = this._protectedEnpoints.apiReturn.some((e) => e.regex.test(path));\n\t\tthis._protectedEnpoints.cache[path] = isProtectedEndpoint;\n\t\treturn isProtectedEndpoint;\n\t}\n\n\tprivate checkGenericNut(num: 7 | 8 | 9 | 10 | 11 | 12 | 14 | 20) {\n\t\tif (this._mintInfo.nuts[num]?.supported) {\n\t\t\treturn { supported: true };\n\t\t}\n\t\treturn { supported: false };\n\t}\n\tprivate checkMintMelt(num: 4 | 5) {\n\t\tconst mintMeltInfo = this._mintInfo.nuts[num];\n\t\tif (mintMeltInfo && mintMeltInfo.methods.length > 0 && !mintMeltInfo.disabled) {\n\t\t\treturn { disabled: false, params: mintMeltInfo.methods };\n\t\t}\n\t\treturn { disabled: true, params: mintMeltInfo.methods };\n\t}\n\tprivate checkNut17() {\n\t\tif (this._mintInfo.nuts[17] && this._mintInfo.nuts[17].supported.length > 0) {\n\t\t\treturn { supported: true, params: this._mintInfo.nuts[17].supported };\n\t\t}\n\t\treturn { supported: false };\n\t}\n\tprivate checkNut15() {\n\t\tif (this._mintInfo.nuts[15] && this._mintInfo.nuts[15].methods.length > 0) {\n\t\t\treturn { supported: true, params: this._mintInfo.nuts[15].methods };\n\t\t}\n\t\treturn { supported: false };\n\t}\n\n\tget contact() {\n\t\treturn this._mintInfo.contact;\n\t}\n\n\tget description() {\n\t\treturn this._mintInfo.description;\n\t}\n\n\tget description_long() {\n\t\treturn this._mintInfo.description_long;\n\t}\n\n\tget name() {\n\t\treturn this._mintInfo.name;\n\t}\n\n\tget pubkey() {\n\t\treturn this._mintInfo.pubkey;\n\t}\n\n\tget nuts() {\n\t\treturn this._mintInfo.nuts;\n\t}\n\n\tget version() {\n\t\treturn this._mintInfo.version;\n\t}\n\n\tget motd() {\n\t\treturn this._mintInfo.motd;\n\t}\n}\n","import { ConnectionManager, WSConnection } from './WSConnection.js';\nimport type {\n\tCheckStatePayload,\n\tCheckStateResponse,\n\tGetInfoResponse,\n\tMeltPayload,\n\tMintActiveKeys,\n\tMintAllKeysets,\n\tPostRestoreResponse,\n\tSerializedBlindedMessage,\n\tSwapPayload,\n\tSwapResponse,\n\tMintQuotePayload,\n\tMintPayload,\n\tMintResponse,\n\tPostRestorePayload,\n\tMeltQuotePayload,\n\tMeltQuoteResponse,\n\tPartialMintQuoteResponse,\n\tPartialMeltQuoteResponse\n} from './model/types/index.js';\nimport { MeltQuoteState } from './model/types/index.js';\nimport request from './request.js';\nimport { isObj, joinUrls, sanitizeUrl } from './utils.js';\nimport {\n\tMeltQuoteResponsePaidDeprecated,\n\thandleMeltQuoteResponseDeprecated\n} from './legacy/nut-05.js';\nimport {\n\tMintQuoteResponsePaidDeprecated,\n\thandleMintQuoteResponseDeprecated\n} from './legacy/nut-04.js';\nimport { handleMintInfoContactFieldDeprecated } from './legacy/nut-06.js';\nimport { MintInfo } from './model/MintInfo.js';\n/**\n * Class represents Cashu Mint API. This class contains Lower level functions that are implemented by CashuWallet.\n */\nclass CashuMint {\n\tprivate ws?: WSConnection;\n\tprivate _mintInfo?: MintInfo;\n\tprivate _authTokenGetter?: () => Promise<string>;\n\tprivate _checkNut22 = false;\n\t/**\n\t * @param _mintUrl requires mint URL to create this object\n\t * @param _customRequest if passed, use custom request implementation for network communication with the mint\n\t * @param [authTokenGetter] a function that is called by the CashuMint instance to obtain a NUT-22 BlindedAuthToken (e.g. from a database or localstorage)\n\t */\n\tconstructor(\n\t\tprivate _mintUrl: string,\n\t\tprivate _customRequest?: typeof request,\n\t\tauthTokenGetter?: () => Promise<string>\n\t) {\n\t\tthis._mintUrl = sanitizeUrl(_mintUrl);\n\t\tthis._customRequest = _customRequest;\n\t\tif (authTokenGetter) {\n\t\t\tthis._checkNut22 = true;\n\t\t\tthis._authTokenGetter = authTokenGetter;\n\t\t}\n\t}\n\n\t//TODO: v3 - refactor CashuMint to take two or less args.\n\n\tget mintUrl() {\n\t\treturn this._mintUrl;\n\t}\n\n\t/**\n\t * fetches mints info at the /info endpoint\n\t * @param mintUrl\n\t * @param customRequest\n\t */\n\tpublic static async getInfo(\n\t\tmintUrl: string,\n\t\tcustomRequest?: typeof request\n\t): Promise<GetInfoResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst response = await requestInstance<GetInfoResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/info')\n\t\t});\n\t\tconst data = handleMintInfoContactFieldDeprecated(response);\n\t\treturn data;\n\t}\n\t/**\n\t * fetches mints info at the /info endpoint\n\t */\n\tasync getInfo(): Promise<GetInfoResponse> {\n\t\treturn CashuMint.getInfo(this._mintUrl, this._customRequest);\n\t}\n\n\tasync getLazyMintInfo(): Promise<MintInfo> {\n\t\tif (this._mintInfo) {\n\t\t\treturn this._mintInfo;\n\t\t}\n\t\tconst data = await CashuMint.getInfo(this._mintUrl, this._customRequest);\n\t\tthis._mintInfo = new MintInfo(data);\n\t\treturn this._mintInfo;\n\t}\n\n\t/**\n\t * Performs a swap operation with ecash inputs and outputs.\n\t * @param mintUrl\n\t * @param swapPayload payload containing inputs and outputs\n\t * @param customRequest\n\t * @returns signed outputs\n\t */\n\tpublic static async swap(\n\t\tmintUrl: string,\n\t\tswapPayload: SwapPayload,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string\n\t): Promise<SwapResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst data = await requestInstance<SwapResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/swap'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: swapPayload,\n\t\t\theaders\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.signatures)) {\n\t\t\tthrow new Error(data.detail ?? 'bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Performs a swap operation with ecash inputs and outputs.\n\t * @param swapPayload payload containing inputs and outputs\n\t * @returns signed outputs\n\t */\n\tasync swap(swapPayload: SwapPayload): Promise<SwapResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth('/v1/swap');\n\t\treturn CashuMint.swap(this._mintUrl, swapPayload, this._customRequest, blindAuthToken);\n\t}\n\n\t/**\n\t * Requests a new mint quote from the mint.\n\t * @param mintUrl\n\t * @param mintQuotePayload Payload for creating a new mint quote\n\t * @param customRequest\n\t * @returns the mint will create and return a new mint quote containing a payment request for the specified amount and unit\n\t */\n\tpublic static async createMintQuote(\n\t\tmintUrl: string,\n\t\tmintQuotePayload: MintQuotePayload,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string\n\t): Promise<PartialMintQuoteResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst response = await requestInstance<\n\t\t\tPartialMintQuoteResponse & MintQuoteResponsePaidDeprecated\n\t\t>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/mint/quote/bolt11'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: mintQuotePayload,\n\t\t\theaders\n\t\t});\n\t\tconst data = handleMintQuoteResponseDeprecated(response);\n\t\treturn data;\n\t}\n\t/**\n\t * Requests a new mint quote from the mint.\n\t * @param mintQuotePayload Payload for creating a new mint quote\n\t * @returns the mint will create and return a new mint quote containing a payment request for the specified amount and unit\n\t */\n\tasync createMintQuote(mintQuotePayload: MintQuotePayload): Promise<PartialMintQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth('/v1/mint/quote/bolt11');\n\t\treturn CashuMint.createMintQuote(\n\t\t\tthis._mintUrl,\n\t\t\tmintQuotePayload,\n\t\t\tthis._customRequest,\n\t\t\tblindAuthToken\n\t\t);\n\t}\n\n\t/**\n\t * Gets an existing mint quote from the mint.\n\t * @param mintUrl\n\t * @param quote Quote ID\n\t * @param customRequest\n\t * @returns the mint will create and return a Lightning invoice for the specified amount\n\t */\n\tpublic static async checkMintQuote(\n\t\tmintUrl: string,\n\t\tquote: string,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string\n\t): Promise<PartialMintQuoteResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst response = await requestInstance<\n\t\t\tPartialMintQuoteResponse & MintQuoteResponsePaidDeprecated\n\t\t>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/mint/quote/bolt11', quote),\n\t\t\tmethod: 'GET',\n\t\t\theaders\n\t\t});\n\n\t\tconst data = handleMintQuoteResponseDeprecated(response);\n\t\treturn data;\n\t}\n\t/**\n\t * Gets an existing mint quote from the mint.\n\t * @param quote Quote ID\n\t * @returns the mint will create and return a Lightning invoice for the specified amount\n\t */\n\tasync checkMintQuote(quote: string): Promise<PartialMintQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth(`/v1/mint/quote/bolt11/${quote}`);\n\t\treturn CashuMint.checkMintQuote(this._mintUrl, quote, this._customRequest, blindAuthToken);\n\t}\n\n\t/**\n\t * Mints new tokens by requesting blind signatures on the provided outputs.\n\t * @param mintUrl\n\t * @param mintPayload Payload containing the outputs to get blind signatures on\n\t * @param customRequest\n\t * @returns serialized blinded signatures\n\t */\n\tpublic static async mint(\n\t\tmintUrl: string,\n\t\tmintPayload: MintPayload,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string\n\t) {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst data = await requestInstance<MintResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/mint/bolt11'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: mintPayload,\n\t\t\theaders\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.signatures)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Mints new tokens by requesting blind signatures on the provided outputs.\n\t * @param mintPayload Payload containing the outputs to get blind signatures on\n\t * @returns serialized blinded signatures\n\t */\n\tasync mint(mintPayload: MintPayload) {\n\t\tconst blindAuthToken = await this.handleBlindAuth('/v1/mint/bolt11');\n\t\treturn CashuMint.mint(this._mintUrl, mintPayload, this._customRequest, blindAuthToken);\n\t}\n\n\t/**\n\t * Requests a new melt quote from the mint.\n\t * @param mintUrl\n\t * @param MeltQuotePayload\n\t * @returns\n\t */\n\tpublic static async createMeltQuote(\n\t\tmintUrl: string,\n\t\tmeltQuotePayload: MeltQuotePayload,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string\n\t): Promise<PartialMeltQuoteResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst response = await requestInstance<\n\t\t\tPartialMeltQuoteResponse & MeltQuoteResponsePaidDeprecated\n\t\t>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/melt/quote/bolt11'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: meltQuotePayload,\n\t\t\theaders\n\t\t});\n\n\t\tconst data = handleMeltQuoteResponseDeprecated(response);\n\n\t\tif (\n\t\t\t!isObj(data) ||\n\t\t\ttypeof data?.amount !== 'number' ||\n\t\t\ttypeof data?.fee_reserve !== 'number' ||\n\t\t\ttypeof data?.quote !== 'string'\n\t\t) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\t\treturn data;\n\t}\n\t/**\n\t * Requests a new melt quote from the mint.\n\t * @param MeltQuotePayload\n\t * @returns\n\t */\n\tasync createMeltQuote(meltQuotePayload: MeltQuotePayload): Promise<PartialMeltQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth('/v1/melt/quote/bolt11');\n\t\treturn CashuMint.createMeltQuote(\n\t\t\tthis._mintUrl,\n\t\t\tmeltQuotePayload,\n\t\t\tthis._customRequest,\n\t\t\tblindAuthToken\n\t\t);\n\t}\n\n\t/**\n\t * Gets an existing melt quote.\n\t * @param mintUrl\n\t * @param quote Quote ID\n\t * @returns\n\t */\n\tpublic static async checkMeltQuote(\n\t\tmintUrl: string,\n\t\tquote: string,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string\n\t): Promise<PartialMeltQuoteResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst response = await requestInstance<MeltQuoteResponse & MeltQuoteResponsePaidDeprecated>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/melt/quote/bolt11', quote),\n\t\t\tmethod: 'GET',\n\t\t\theaders\n\t\t});\n\n\t\tconst data = handleMeltQuoteResponseDeprecated(response);\n\n\t\tif (\n\t\t\t!isObj(data) ||\n\t\t\ttypeof data?.amount !== 'number' ||\n\t\t\ttypeof data?.fee_reserve !== 'number' ||\n\t\t\ttypeof data?.quote !== 'string' ||\n\t\t\ttypeof data?.state !== 'string' ||\n\t\t\t!Object.values(MeltQuoteState).includes(data.state)\n\t\t) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Gets an existing melt quote.\n\t * @param quote Quote ID\n\t * @returns\n\t */\n\tasync checkMeltQuote(quote: string): Promise<PartialMeltQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth(`/v1/melt/quote/bolt11/${quote}`);\n\t\treturn CashuMint.checkMeltQuote(this._mintUrl, quote, this._customRequest, blindAuthToken);\n\t}\n\n\t/**\n\t * Requests the mint to pay for a Bolt11 payment request by providing ecash as inputs to be spent. The inputs contain the amount and the fee_reserves for a Lightning payment. The payload can also contain blank outputs in order to receive back overpaid Lightning fees.\n\t * @param mintUrl\n\t * @param meltPayload\n\t * @param customRequest\n\t * @returns\n\t */\n\tpublic static async melt(\n\t\tmintUrl: string,\n\t\tmeltPayload: MeltPayload,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string\n\t): Promise<PartialMeltQuoteResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst response = await requestInstance<MeltQuoteResponse & MeltQuoteResponsePaidDeprecated>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/melt/bolt11'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: meltPayload,\n\t\t\theaders\n\t\t});\n\n\t\tconst data = handleMeltQuoteResponseDeprecated(response);\n\n\t\tif (\n\t\t\t!isObj(data) ||\n\t\t\ttypeof data?.state !== 'string' ||\n\t\t\t!Object.values(MeltQuoteState).includes(data.state)\n\t\t) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Ask mint to perform a melt operation. This pays a lightning invoice and destroys tokens matching its amount + fees\n\t * @param meltPayload\n\t * @returns\n\t */\n\tasync melt(meltPayload: MeltPayload): Promise<PartialMeltQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth('/v1/melt/bolt11');\n\t\treturn CashuMint.melt(this._mintUrl, meltPayload, this._customRequest, blindAuthToken);\n\t}\n\t/**\n\t * Checks if specific proofs have already been redeemed\n\t * @param mintUrl\n\t * @param checkPayload\n\t * @param customRequest\n\t * @returns redeemed and unredeemed ordered list of booleans\n\t */\n\tpublic static async check(\n\t\tmintUrl: string,\n\t\tcheckPayload: CheckStatePayload,\n\t\tcustomRequest?: typeof request\n\t): Promise<CheckStateResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst data = await requestInstance<CheckStateResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/checkstate'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: checkPayload\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.states)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Get the mints public keys\n\t * @param mintUrl\n\t * @param keysetId optional param to get the keys for a specific keyset. If not specified, the keys from all active keysets are fetched\n\t * @param customRequest\n\t * @returns\n\t */\n\tpublic static async getKeys(\n\t\tmintUrl: string,\n\t\tkeysetId?: string,\n\t\tcustomRequest?: typeof request\n\t): Promise<MintActiveKeys> {\n\t\t// backwards compatibility for base64 encoded keyset ids\n\t\tif (keysetId) {\n\t\t\t// make the keysetId url safe\n\t\t\tkeysetId = keysetId.replace(/\\//g, '_').replace(/\\+/g, '-');\n\t\t}\n\t\tconst requestInstance = customRequest || request;\n\t\tconst data = await requestInstance<MintActiveKeys>({\n\t\t\tendpoint: keysetId ? joinUrls(mintUrl, '/v1/keys', keysetId) : joinUrls(mintUrl, '/v1/keys')\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data.keysets)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Get the mints public keys\n\t * @param keysetId optional param to get the keys for a specific keyset. If not specified, the keys from all active keysets are fetched\n\t * @returns the mints public keys\n\t */\n\tasync getKeys(keysetId?: string, mintUrl?: string): Promise<MintActiveKeys> {\n\t\tconst allKeys = await CashuMint.getKeys(\n\t\t\tmintUrl || this._mintUrl,\n\t\t\tkeysetId,\n\t\t\tthis._customRequest\n\t\t);\n\t\treturn allKeys;\n\t}\n\t/**\n\t * Get the mints keysets in no specific order\n\t * @param mintUrl\n\t * @param customRequest\n\t * @returns all the mints past and current keysets.\n\t */\n\tpublic static async getKeySets(\n\t\tmintUrl: string,\n\t\tcustomRequest?: typeof request\n\t): Promise<MintAllKeysets> {\n\t\tconst requestInstance = customRequest || request;\n\t\treturn requestInstance<MintAllKeysets>({ endpoint: joinUrls(mintUrl, '/v1/keysets') });\n\t}\n\n\t/**\n\t * Get the mints keysets in no specific order\n\t * @returns all the mints past and current keysets.\n\t */\n\tasync getKeySets(): Promise<MintAllKeysets> {\n\t\treturn CashuMint.getKeySets(this._mintUrl, this._customRequest);\n\t}\n\n\t/**\n\t * Checks if specific proofs have already been redeemed\n\t * @param checkPayload\n\t * @returns redeemed and unredeemed ordered list of booleans\n\t */\n\tasync check(checkPayload: CheckStatePayload): Promise<CheckStateResponse> {\n\t\treturn CashuMint.check(this._mintUrl, checkPayload, this._customRequest);\n\t}\n\n\tpublic static async restore(\n\t\tmintUrl: string,\n\t\trestorePayload: PostRestorePayload,\n\t\tcustomRequest?: typeof request\n\t): Promise<PostRestoreResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst data = await requestInstance<PostRestoreResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/restore'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: restorePayload\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.outputs) || !Array.isArray(data?.signatures)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\tasync restore(restorePayload: {\n\t\toutputs: Array<SerializedBlindedMessage>;\n\t}): Promise<PostRestoreResponse> {\n\t\treturn CashuMint.restore(this._mintUrl, restorePayload, this._customRequest);\n\t}\n\n\t/**\n\t * Tries to establish a websocket connection with the websocket mint url according to NUT-17\n\t */\n\tasync connectWebSocket() {\n\t\tif (this.ws) {\n\t\t\tawait this.ws.ensureConnection();\n\t\t} else {\n\t\t\tconst mintUrl = new URL(this._mintUrl);\n\t\t\tconst wsSegment = 'v1/ws';\n\t\t\tif (mintUrl.pathname) {\n\t\t\t\tif (mintUrl.pathname.endsWith('/')) {\n\t\t\t\t\tmintUrl.pathname += wsSegment;\n\t\t\t\t} else {\n\t\t\t\t\tmintUrl.pathname += '/' + wsSegment;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.ws = ConnectionManager.getInstance().getConnection(\n\t\t\t\t`${mintUrl.protocol === 'https:' ? 'wss' : 'ws'}://${mintUrl.host}${mintUrl.pathname}`\n\t\t\t);\n\t\t\ttry {\n\t\t\t\tawait this.ws.connect();\n\t\t\t} catch (e) {\n\t\t\t\tconsole.log(e);\n\t\t\t\tthrow new Error('Failed to connect to WebSocket...');\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Closes a websocket connection\n\t */\n\tdisconnectWebSocket() {\n\t\tif (this.ws) {\n\t\t\tthis.ws.close();\n\t\t}\n\t}\n\n\tget webSocketConnection() {\n\t\treturn this.ws;\n\t}\n\n\tasync handleBlindAuth(path: string) {\n\t\tif (!this._checkNut22) {\n\t\t\treturn;\n\t\t}\n\t\tconst info = await this.getLazyMintInfo();\n\t\tif (info.requiresBlindAuthToken(path)) {\n\t\t\tif (!this._authTokenGetter) {\n\t\t\t\tthrow new Error('Can not call a protected endpoint without authProofGetter');\n\t\t\t}\n\t\t\treturn this._authTokenGetter();\n\t\t}\n\t\treturn undefined;\n\t}\n}\n\nexport { CashuMint };\n","import { Secret } from './index.js';\n\nexport const parseSecret = (secret: string | Uint8Array): Secret => {\n\ttry {\n\t\tif (secret instanceof Uint8Array) {\n\t\t\tsecret = new TextDecoder().decode(secret);\n\t\t}\n\t\treturn JSON.parse(secret);\n\t} catch (e) {\n\t\tthrow new Error(\"can't parse secret\");\n\t}\n};\n","import { PrivKey, bytesToHex, hexToBytes } from '@noble/curves/abstract/utils';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { schnorr } from '@noble/curves/secp256k1';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { parseSecret } from '../common/NUT11.js';\nimport { Proof, Secret } from '../common/index.js';\nimport { BlindedMessage } from './index.js';\n\nexport const createP2PKsecret = (pubkey: string): Uint8Array => {\n\tconst newSecret: Secret = [\n\t\t'P2PK',\n\t\t{\n\t\t\tnonce: bytesToHex(randomBytes(32)),\n\t\t\tdata: pubkey\n\t\t}\n\t];\n\tconst parsed = JSON.stringify(newSecret);\n\treturn new TextEncoder().encode(parsed);\n};\n\nexport const signP2PKsecret = (secret: Uint8Array, privateKey: PrivKey) => {\n\tconst msghash = sha256(new TextDecoder().decode(secret));\n\tconst sig = schnorr.sign(msghash, privateKey);\n\treturn sig;\n};\n\nexport const signBlindedMessage = (B_: string, privateKey: PrivKey): Uint8Array => {\n\tconst msgHash = sha256(B_);\n\tconst sig = schnorr.sign(msgHash, privateKey);\n\treturn sig;\n};\n\nexport const getSignedProofs = (\n\tproofs: Array<Proof>,\n\tprivateKey: string | string[]\n): Array<Proof> => {\n\tlet keypairs: Array<{ priv: string; pub: string }> = [];\n\tlet pk = '';\n\n\tif (privateKey instanceof Array) {\n\t\tfor (const k of privateKey) {\n\t\t\tkeypairs.push({ priv: k, pub: bytesToHex(schnorr.getPublicKey(k)) });\n\t\t}\n\t} else {\n\t\tpk = privateKey;\n\t}\n\n\treturn proofs.map((p) => {\n\t\ttry {\n\t\t\tconst parsed: Secret = parseSecret(p.secret);\n\t\t\tif (parsed[0] !== 'P2PK') {\n\t\t\t\tthrow new Error('unknown secret type');\n\t\t\t}\n\t\t\tif (keypairs.length) {\n\t\t\t\tconst matchingKey = keypairs.find((pair) => parsed[1].data === pair.pub)?.priv;\n\t\t\t\tif (!matchingKey) {\n\t\t\t\t\tthrow new Error('no matching key found');\n\t\t\t\t} else {\n\t\t\t\t\tpk = matchingKey;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn getSignedProof(p, hexToBytes(pk));\n\t\t} catch (error) {\n\t\t\treturn p;\n\t\t}\n\t});\n};\n\nexport const getSignedOutput = (output: BlindedMessage, privateKey: PrivKey): BlindedMessage => {\n\tconst B_ = output.B_.toHex(true);\n\tconst signature = signBlindedMessage(B_, privateKey);\n\toutput.witness = { signatures: [bytesToHex(signature)] };\n\treturn output;\n};\n\nexport const getSignedOutputs = (\n\toutputs: Array<BlindedMessage>,\n\tprivateKey: string\n): Array<BlindedMessage> => {\n\treturn outputs.map((o) => getSignedOutput(o, privateKey));\n};\n\nexport const getSignedProof = (proof: Proof, privateKey: PrivKey): Proof => {\n\tif (!proof.witness) {\n\t\tproof.witness = {\n\t\t\tsignatures: [bytesToHex(signP2PKsecret(proof.secret, privateKey))]\n\t\t};\n\t}\n\treturn proof;\n};\n","import { ProjPointType } from '@noble/curves/abstract/weierstrass';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { bytesToNumber } from '../util/utils.js';\nimport type {\n\tBlindSignature,\n\tProof,\n\tSerializedBlindedMessage,\n\tSerializedProof\n} from '../common/index.js';\nimport { hashToCurve, pointFromHex } from '../common/index.js';\nimport { Witness } from '../common/index';\nimport { PrivKey } from '@noble/curves/abstract/utils';\nimport { getSignedOutput } from './NUT11.js';\n\nexport type BlindedMessage = {\n\tB_: ProjPointType<bigint>;\n\tr: bigint;\n\tsecret: Uint8Array;\n\twitness?: Witness;\n};\n\nexport function createRandomBlindedMessage(privateKey?: PrivKey): BlindedMessage {\n\treturn blindMessage(\n\t\trandomBytes(32),\n\t\tbytesToNumber(secp256k1.utils.randomPrivateKey()),\n\t\tprivateKey\n\t);\n}\n\nexport function blindMessage(secret: Uint8Array, r?: bigint, privateKey?: PrivKey): BlindedMessage {\n\tconst Y = hashToCurve(secret);\n\tif (!r) {\n\t\tr = bytesToNumber(secp256k1.utils.randomPrivateKey());\n\t}\n\tconst rG = secp256k1.ProjectivePoint.BASE.multiply(r);\n\tconst B_ = Y.add(rG);\n\tif (privateKey !== undefined) {\n\t\treturn getSignedOutput({ B_, r, secret }, privateKey);\n\t}\n\treturn { B_, r, secret };\n}\n\nexport function unblindSignature(\n\tC_: ProjPointType<bigint>,\n\tr: bigint,\n\tA: ProjPointType<bigint>\n): ProjPointType<bigint> {\n\tconst C = C_.subtract(A.multiply(r));\n\treturn C;\n}\n\nexport function constructProofFromPromise(\n\tpromise: BlindSignature,\n\tr: bigint,\n\tsecret: Uint8Array,\n\tkey: ProjPointType<bigint>\n): Proof {\n\tconst A = key;\n\tconst C = unblindSignature(promise.C_, r, A);\n\tconst proof = {\n\t\tid: promise.id,\n\t\tamount: promise.amount,\n\t\tsecret,\n\t\tC\n\t};\n\treturn proof;\n}\n\nexport const serializeProof = (proof: Proof): SerializedProof => {\n\treturn {\n\t\tamount: proof.amount,\n\t\tC: proof.C.toHex(true),\n\t\tid: proof.id,\n\t\tsecret: new TextDecoder().decode(proof.secret),\n\t\twitness: JSON.stringify(proof.witness)\n\t};\n};\n\nexport const deserializeProof = (proof: SerializedProof): Proof => {\n\treturn {\n\t\tamount: proof.amount,\n\t\tC: pointFromHex(proof.C),\n\t\tid: proof.id,\n\t\tsecret: new TextEncoder().encode(proof.secret),\n\t\twitness: proof.witness ? JSON.parse(proof.witness) : undefined\n\t};\n};\nexport const serializeBlindedMessage = (\n\tbm: BlindedMessage,\n\tamount: number\n): SerializedBlindedMessage => {\n\treturn {\n\t\tB_: bm.B_.toHex(true),\n\t\tamount: amount\n\t};\n};\n","import { schnorr } from '@noble/curves/secp256k1';\nimport { SerializedBlindedMessage } from '../../model/types';\nimport { bytesToHex, hexToBytes } from '@noble/hashes/utils';\nimport { sha256 } from '@noble/hashes/sha256';\n\nfunction constructMessage(\n\tquote: string,\n\tblindedMessages: Array<SerializedBlindedMessage>\n): Uint8Array {\n\tlet message = quote;\n\tfor (const blindedMessage of blindedMessages) {\n\t\tmessage += blindedMessage.B_;\n\t}\n\tconst msgbytes = new TextEncoder().encode(message);\n\treturn sha256(msgbytes);\n}\n\nexport function signMintQuote(\n\tprivkey: string,\n\tquote: string,\n\tblindedMessages: Array<SerializedBlindedMessage>\n): string {\n\tconst message = constructMessage(quote, blindedMessages);\n\tconst privkeyBytes = hexToBytes(privkey);\n\tconst signature = schnorr.sign(message, privkeyBytes);\n\treturn bytesToHex(signature);\n}\n\nexport function verifyMintQuoteSignature(\n\tpubkey: string,\n\tquote: string,\n\tblindedMessages: Array<SerializedBlindedMessage>,\n\tsignature: string\n): boolean {\n\tconst sigbytes = hexToBytes(signature);\n\tlet pubkeyBytes = hexToBytes(pubkey);\n\tif (pubkeyBytes.length !== 33) return false;\n\tpubkeyBytes = pubkeyBytes.slice(1);\n\tconst message = constructMessage(quote, blindedMessages);\n\treturn schnorr.verify(sigbytes, message, pubkeyBytes);\n}\n","import { SerializedBlindedMessage } from './types/index.js';\nimport { ProjPointType } from '@noble/curves/abstract/weierstrass';\n\nclass BlindedMessage {\n\tamount: number;\n\tB_: ProjPointType<bigint>;\n\tid: string;\n\tconstructor(amount: number, B_: ProjPointType<bigint>, id: string) {\n\t\tthis.amount = amount;\n\t\tthis.B_ = B_;\n\t\tthis.id = id;\n\t}\n\tgetSerializedBlindedMessage(): SerializedBlindedMessage {\n\t\treturn { amount: this.amount, B_: this.B_.toHex(true), id: this.id };\n\t}\n}\nexport { BlindedMessage };\n","import { HDKey } from '@scure/bip32';\nimport { getKeysetIdInt } from '../common/index.js';\n\nconst STANDARD_DERIVATION_PATH = `m/129372'/0'`;\n\nenum DerivationType {\n\tSECRET = 0,\n\tBLINDING_FACTOR = 1\n}\n\nexport const deriveSecret = (seed: Uint8Array, keysetId: string, counter: number): Uint8Array => {\n\treturn derive(seed, keysetId, counter, DerivationType.SECRET);\n};\n\nexport const deriveBlindingFactor = (\n\tseed: Uint8Array,\n\tkeysetId: string,\n\tcounter: number\n): Uint8Array => {\n\treturn derive(seed, keysetId, counter, DerivationType.BLINDING_FACTOR);\n};\n\nconst derive = (\n\tseed: Uint8Array,\n\tkeysetId: string,\n\tcounter: number,\n\tsecretOrBlinding: DerivationType\n): Uint8Array => {\n\tconst hdkey = HDKey.fromMasterSeed(seed);\n\tconst keysetIdInt = getKeysetIdInt(keysetId);\n\tconst derivationPath = `${STANDARD_DERIVATION_PATH}/${keysetIdInt}'/${counter}'/${secretOrBlinding}`;\n\tconst derived = hdkey.derive(derivationPath);\n\tif (derived.privateKey === null) {\n\t\tthrow new Error('Could not derive private key');\n\t}\n\treturn derived.privateKey;\n};\n","import {\n\tMintKeys,\n\tProof,\n\tSerializedBlindedMessage,\n\tSerializedBlindedSignature,\n\tSerializedDLEQ\n} from './types';\nimport { blindMessage, constructProofFromPromise, serializeProof } from '../crypto/client/index';\nimport { BlindedMessage } from './BlindedMessage';\nimport { bytesToHex, hexToBytes, randomBytes } from '@noble/hashes/utils';\nimport { DLEQ, pointFromHex } from '../crypto/common/index.js';\nimport { bytesToNumber, numberToHexPadded64, splitAmount } from '../utils';\nimport { deriveBlindingFactor, deriveSecret } from '../crypto/client/NUT09.js';\n\nexport interface OutputDataLike {\n\tblindedMessage: SerializedBlindedMessage;\n\tblindingFactor: bigint;\n\tsecret: Uint8Array;\n\n\ttoProof: (signature: SerializedBlindedSignature, keyset: MintKeys) => Proof;\n}\n\nexport type OutputDataFactory = (amount: number, keys: MintKeys) => OutputDataLike;\n\nexport function isOutputDataFactory(\n\tvalue: Array<OutputData> | OutputDataFactory\n): value is OutputDataFactory {\n\treturn typeof value === 'function';\n}\n\nexport class OutputData implements OutputDataLike {\n\tblindedMessage: SerializedBlindedMessage;\n\tblindingFactor: bigint;\n\tsecret: Uint8Array;\n\n\tconstructor(blindedMessage: SerializedBlindedMessage, blidingFactor: bigint, secret: Uint8Array) {\n\t\tthis.secret = secret;\n\t\tthis.blindingFactor = blidingFactor;\n\t\tthis.blindedMessage = blindedMessage;\n\t}\n\n\ttoProof(sig: SerializedBlindedSignature, keyset: MintKeys) {\n\t\tlet dleq: DLEQ | undefined;\n\t\tif (sig.dleq) {\n\t\t\tdleq = {\n\t\t\t\ts: hexToBytes(sig.dleq.s),\n\t\t\t\te: hexToBytes(sig.dleq.e),\n\t\t\t\tr: this.blindingFactor\n\t\t\t};\n\t\t}\n\t\tconst blindSignature = {\n\t\t\tid: sig.id,\n\t\t\tamount: sig.amount,\n\t\t\tC_: pointFromHex(sig.C_),\n\t\t\tdleq: dleq\n\t\t};\n\t\tconst A = pointFromHex(keyset.keys[sig.amount]);\n\t\tconst proof = constructProofFromPromise(blindSignature, this.blindingFactor, this.secret, A);\n\t\tconst serializedProof = {\n\t\t\t...serializeProof(proof),\n\t\t\t...(dleq && {\n\t\t\t\tdleq: {\n\t\t\t\t\ts: bytesToHex(dleq.s),\n\t\t\t\t\te: bytesToHex(dleq.e),\n\t\t\t\t\tr: numberToHexPadded64(dleq.r ?? BigInt(0))\n\t\t\t\t} as SerializedDLEQ\n\t\t\t})\n\t\t} as Proof;\n\t\treturn serializedProof;\n\t}\n\n\tstatic createP2PKData(\n\t\tp2pk: { pubkey: string; locktime?: number; refundKeys?: Array<string> },\n\t\tamount: number,\n\t\tkeyset: MintKeys,\n\t\tcustomSplit?: Array<number>\n\t) {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a) => this.createSingleP2PKData(p2pk, a, keyset.id));\n\t}\n\n\tstatic createSingleP2PKData(\n\t\tp2pk: { pubkey: string; locktime?: number; refundKeys?: Array<string> },\n\t\tamount: number,\n\t\tkeysetId: string\n\t) {\n\t\tconst newSecret: [string, { nonce: string; data: string; tags: Array<any> }] = [\n\t\t\t'P2PK',\n\t\t\t{\n\t\t\t\tnonce: bytesToHex(randomBytes(32)),\n\t\t\t\tdata: p2pk.pubkey,\n\t\t\t\ttags: []\n\t\t\t}\n\t\t];\n\t\tif (p2pk.locktime) {\n\t\t\tnewSecret[1].tags.push(['locktime', p2pk.locktime]);\n\t\t}\n\t\tif (p2pk.refundKeys) {\n\t\t\tnewSecret[1].tags.push(['refund', ...p2pk.refundKeys]);\n\t\t}\n\t\tconst parsed = JSON.stringify(newSecret);\n\t\tconst secretBytes = new TextEncoder().encode(parsed);\n\t\tconst { r, B_ } = blindMessage(secretBytes);\n\t\treturn new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tsecretBytes\n\t\t);\n\t}\n\n\tstatic createRandomData(amount: number, keyset: MintKeys, customSplit?: Array<number>) {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a) => this.createSingleRandomData(a, keyset.id));\n\t}\n\n\tstatic createSingleRandomData(amount: number, keysetId: string) {\n\t\tconst randomHex = bytesToHex(randomBytes(32));\n\t\tconst secretBytes = new TextEncoder().encode(randomHex);\n\t\tconst { r, B_ } = blindMessage(secretBytes);\n\t\treturn new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tsecretBytes\n\t\t);\n\t}\n\n\tstatic createDeterministicData(\n\t\tamount: number,\n\t\tseed: Uint8Array,\n\t\tcounter: number,\n\t\tkeyset: MintKeys,\n\t\tcustomSplit?: Array<number>\n\t): Array<OutputData> {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a, i) =>\n\t\t\tthis.createSingleDeterministicData(a, seed, counter + i, keyset.id)\n\t\t);\n\t}\n\n\tstatic createSingleDeterministicData(\n\t\tamount: number,\n\t\tseed: Uint8Array,\n\t\tcounter: number,\n\t\tkeysetId: string\n\t) {\n\t\tconst secretBytes = deriveSecret(seed, keysetId, counter);\n\t\tconst secretBytesAsHex = bytesToHex(secretBytes);\n\t\tconst utf8SecretBytes = new TextEncoder().encode(secretBytesAsHex);\n\t\tconst deterministicR = bytesToNumber(deriveBlindingFactor(seed, keysetId, counter));\n\t\tconst { r, B_ } = blindMessage(utf8SecretBytes, deterministicR);\n\t\treturn new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tutf8SecretBytes\n\t\t);\n\t}\n}\n","import { serializeProof } from './crypto/client/index.js';\nimport { getSignedProofs } from './crypto/client/NUT11.js';\nimport { hashToCurve, pointFromHex, type Proof as NUT11Proof } from './crypto/common/index.js';\nimport { CashuMint } from './CashuMint.js';\nimport { MintInfo } from './model/MintInfo.js';\nimport {\n\tGetInfoResponse,\n\tMeltProofOptions,\n\tMeltQuoteState,\n\tMintProofOptions,\n\tMintQuoteResponse,\n\tMintQuoteState,\n\tOutputAmounts,\n\tProofState,\n\tReceiveOptions,\n\tRestoreOptions,\n\tSendOptions,\n\tSerializedBlindedSignature,\n\tSwapOptions,\n\ttype MeltPayload,\n\ttype MeltProofsResponse,\n\ttype MeltQuotePayload,\n\ttype MeltQuoteResponse,\n\ttype MintKeys,\n\ttype MintKeyset,\n\ttype MintPayload,\n\ttype MintQuotePayload,\n\ttype Proof,\n\ttype SendResponse,\n\ttype Token,\n\tMPPOption,\n\tMeltQuoteOptions,\n\tSwapTransaction,\n\tLockedMintQuoteResponse,\n\tPartialMintQuoteResponse,\n\tPartialMeltQuoteResponse\n} from './model/types/index.js';\nimport { SubscriptionCanceller } from './model/types/wallet/websocket.js';\nimport {\n\tgetDecodedToken,\n\tgetKeepAmounts,\n\thasValidDleq,\n\tsplitAmount,\n\tstripDleq,\n\tsumProofs\n} from './utils.js';\nimport { signMintQuote } from './crypto/client/NUT20.js';\nimport {\n\tOutputData,\n\tOutputDataFactory,\n\tOutputDataLike,\n\tisOutputDataFactory\n} from './model/OutputData.js';\n\n/**\n * The default number of proofs per denomination to keep in a wallet.\n */\nconst DEFAULT_DENOMINATION_TARGET = 3;\n\n/**\n * The default unit for the wallet, if not specified in constructor.\n */\nconst DEFAULT_UNIT = 'sat';\n\n/**\n * Class that represents a Cashu wallet.\n * This class should act as the entry point for this library\n */\nclass CashuWallet {\n\tprivate _keys: Map<string, MintKeys> = new Map();\n\tprivate _keysetId: string | undefined;\n\tprivate _keysets: Array<MintKeyset> = [];\n\tprivate _seed: Uint8Array | undefined = undefined;\n\tprivate _unit = DEFAULT_UNIT;\n\tprivate _mintInfo: MintInfo | undefined = undefined;\n\tprivate _denominationTarget = DEFAULT_DENOMINATION_TARGET;\n\tprivate _keepFactory: OutputDataFactory | undefined;\n\n\tmint: CashuMint;\n\n\t/**\n\t * @param mint Cashu mint instance is used to make api calls\n\t * @param options.unit optionally set unit (default is 'sat')\n\t * @param options.keys public keys from the mint (will be fetched from mint if not provided)\n\t * @param options.keysets keysets from the mint (will be fetched from mint if not provided)\n\t * @param options.mintInfo mint info from the mint (will be fetched from mint if not provided)\n\t * @param options.denominationTarget target number proofs per denomination (default: see @constant DEFAULT_DENOMINATION_TARGET)\n\t * @param options.bip39seed BIP39 seed for deterministic secrets.\n\t * @param options.keepFactory A function that will be used by all parts of the library that produce proofs to be kept (change, etc.).\n\t * This can lead to poor performance, in which case the seed should be directly provided\n\t */\n\tconstructor(\n\t\tmint: CashuMint,\n\t\toptions?: {\n\t\t\tunit?: string;\n\t\t\tkeys?: Array<MintKeys> | MintKeys;\n\t\t\tkeysets?: Array<MintKeyset>;\n\t\t\tmintInfo?: GetInfoResponse;\n\t\t\tbip39seed?: Uint8Array;\n\t\t\tdenominationTarget?: number;\n\t\t\tkeepFactory?: OutputDataFactory;\n\t\t}\n\t) {\n\t\tthis.mint = mint;\n\t\tlet keys: Array<MintKeys> = [];\n\t\tif (options?.keys && !Array.isArray(options.keys)) {\n\t\t\tkeys = [options.keys];\n\t\t} else if (options?.keys && Array.isArray(options?.keys)) {\n\t\t\tkeys = options?.keys;\n\t\t}\n\t\tif (keys) keys.forEach((key: MintKeys) => this._keys.set(key.id, key));\n\t\tif (options?.unit) this._unit = options?.unit;\n\t\tif (options?.keysets) this._keysets = options.keysets;\n\t\tif (options?.mintInfo) this._mintInfo = new MintInfo(options.mintInfo);\n\t\tif (options?.denominationTarget) {\n\t\t\tthis._denominationTarget = options.denominationTarget;\n\t\t}\n\n\t\tif (options?.bip39seed) {\n\t\t\tif (options.bip39seed instanceof Uint8Array) {\n\t\t\t\tthis._seed = options.bip39seed;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthrow new Error('bip39seed must be a valid UInt8Array');\n\t\t}\n\t\tif (options?.keepFactory) {\n\t\t\tthis._keepFactory = options.keepFactory;\n\t\t}\n\t}\n\n\tget unit(): string {\n\t\treturn this._unit;\n\t}\n\tget keys(): Map<string, MintKeys> {\n\t\treturn this._keys;\n\t}\n\tget keysetId(): string {\n\t\tif (!this._keysetId) {\n\t\t\tthrow new Error('No keysetId set');\n\t\t}\n\t\treturn this._keysetId;\n\t}\n\tset keysetId(keysetId: string) {\n\t\tthis._keysetId = keysetId;\n\t}\n\tget keysets(): Array<MintKeyset> {\n\t\treturn this._keysets;\n\t}\n\tget mintInfo(): MintInfo {\n\t\tif (!this._mintInfo) {\n\t\t\tthrow new Error('Mint info not loaded');\n\t\t}\n\t\treturn this._mintInfo;\n\t}\n\n\t/**\n\t * Get information about the mint\n\t * @returns mint info\n\t */\n\tasync getMintInfo(): Promise<MintInfo> {\n\t\tconst infoRes = await this.mint.getInfo();\n\t\tthis._mintInfo = new MintInfo(infoRes);\n\t\treturn this._mintInfo;\n\t}\n\n\t/**\n\t * Get stored information about the mint or request it if not loaded.\n\t * @returns mint info\n\t */\n\tasync lazyGetMintInfo(): Promise<MintInfo> {\n\t\tif (!this._mintInfo) {\n\t\t\treturn await this.getMintInfo();\n\t\t}\n\t\treturn this._mintInfo;\n\t}\n\n\t/**\n\t * Load mint information, keysets and keys. This function can be called if no keysets are passed in the constructor\n\t */\n\tasync loadMint() {\n\t\tawait this.getMintInfo();\n\t\tawait this.getKeySets();\n\t\tawait this.getKeys();\n\t}\n\n\t/**\n\t * Choose a keyset to activate based on the lowest input fee\n\t *\n\t * Note: this function will filter out deprecated base64 keysets\n\t *\n\t * @param keysets keysets to choose from\n\t * @returns active keyset\n\t */\n\tgetActiveKeyset(keysets: Array<MintKeyset>): MintKeyset {\n\t\tlet activeKeysets = keysets.filter((k: MintKeyset) => k.active);\n\n\t\t// we only consider keyset IDs that start with \"00\"\n\t\tactiveKeysets = activeKeysets.filter((k: MintKeyset) => k.id.startsWith('00'));\n\n\t\tconst activeKeyset = activeKeysets.sort(\n\t\t\t(a: MintKeyset, b: MintKeyset) => (a.input_fee_ppk ?? 0) - (b.input_fee_ppk ?? 0)\n\t\t)[0];\n\t\tif (!activeKeyset) {\n\t\t\tthrow new Error('No active keyset found');\n\t\t}\n\t\treturn activeKeyset;\n\t}\n\n\t/**\n\t * Get keysets from the mint with the unit of the wallet\n\t * @returns keysets with wallet's unit\n\t */\n\tasync getKeySets(): Promise<Array<MintKeyset>> {\n\t\tconst allKeysets = await this.mint.getKeySets();\n\t\tconst unitKeysets = allKeysets.keysets.filter((k: MintKeyset) => k.unit === this._unit);\n\t\tthis._keysets = unitKeysets;\n\t\treturn this._keysets;\n\t}\n\n\t/**\n\t * Get all active keys from the mint and set the keyset with the lowest fees as the active wallet keyset.\n\t * @returns keyset\n\t */\n\tasync getAllKeys(): Promise<Array<MintKeys>> {\n\t\tconst keysets = await this.mint.getKeys();\n\t\tthis._keys = new Map(keysets.keysets.map((k: MintKeys) => [k.id, k]));\n\t\tthis.keysetId = this.getActiveKeyset(this._keysets).id;\n\t\treturn keysets.keysets;\n\t}\n\n\t/**\n\t * Get public keys from the mint. If keys were already fetched, it will return those.\n\t *\n\t * If `keysetId` is set, it will fetch and return that specific keyset.\n\t * Otherwise, we select an active keyset with the unit of the wallet.\n\t *\n\t * @param keysetId optional keysetId to get keys for\n\t * @param forceRefresh? if set to true, it will force refresh the keyset from the mint\n\t * @returns keyset\n\t */\n\tasync getKeys(keysetId?: string, forceRefresh?: boolean): Promise<MintKeys> {\n\t\tif (!(this._keysets.length > 0) || forceRefresh) {\n\t\t\tawait this.getKeySets();\n\t\t}\n\t\t// no keyset id is chosen, let's choose one\n\t\tif (!keysetId) {\n\t\t\tconst localKeyset = this.getActiveKeyset(this._keysets);\n\t\t\tkeysetId = localKeyset.id;\n\t\t}\n\t\t// make sure we have keyset for this id\n\t\tif (!this._keysets.find((k: MintKeyset) => k.id === keysetId)) {\n\t\t\tawait this.getKeySets();\n\t\t\tif (!this._keysets.find((k: MintKeyset) => k.id === keysetId)) {\n\t\t\t\tthrow new Error(`could not initialize keys. No keyset with id '${keysetId}' found`);\n\t\t\t}\n\t\t}\n\n\t\t// make sure we have keys for this id\n\t\tif (!this._keys.get(keysetId)) {\n\t\t\tconst keys = await this.mint.getKeys(keysetId);\n\t\t\tthis._keys.set(keysetId, keys.keysets[0]);\n\t\t}\n\n\t\t// set and return\n\t\tthis.keysetId = keysetId;\n\t\treturn this._keys.get(keysetId) as MintKeys;\n\t}\n\n\t/**\n\t * Receive an encoded or raw Cashu token (only supports single tokens. It will only process the first token in the token array)\n\t * @param {(string|Token)} token - Cashu token, either as string or decoded\n\t * @param {ReceiveOptions} [options] - Optional configuration for token processing\n\t * @returns New token with newly created proofs, token entries that had errors\n\t */\n\tasync receive(token: string | Token, options?: ReceiveOptions): Promise<Array<Proof>> {\n\t\tconst { requireDleq, keysetId, outputAmounts, counter, pubkey, privkey, outputData, p2pk } =\n\t\t\toptions || {};\n\n\t\tif (typeof token === 'string') {\n\t\t\ttoken = getDecodedToken(token);\n\t\t}\n\t\tconst keys = await this.getKeys(keysetId);\n\t\tif (requireDleq) {\n\t\t\tif (token.proofs.some((p: Proof) => !hasValidDleq(p, keys))) {\n\t\t\t\tthrow new Error('Token contains proofs with invalid DLEQ');\n\t\t\t}\n\t\t}\n\t\tconst amount = sumProofs(token.proofs) - this.getFeesForProofs(token.proofs);\n\t\tlet newOutputData: { send: Array<OutputDataLike> | OutputDataFactory } | undefined = undefined;\n\t\tif (outputData) {\n\t\t\tnewOutputData = { send: outputData };\n\t\t} else if (this._keepFactory) {\n\t\t\tnewOutputData = { send: this._keepFactory };\n\t\t}\n\t\tconst swapTransaction = this.createSwapPayload(\n\t\t\tamount,\n\t\t\ttoken.proofs,\n\t\t\tkeys,\n\t\t\toutputAmounts,\n\t\t\tcounter,\n\t\t\tpubkey,\n\t\t\tprivkey,\n\t\t\tnewOutputData,\n\t\t\tp2pk\n\t\t);\n\t\tconst { signatures } = await this.mint.swap(swapTransaction.payload);\n\t\tconst proofs = swapTransaction.outputData.map((d, i) => d.toProof(signatures[i], keys));\n\t\tconst orderedProofs: Array<Proof> = [];\n\t\tswapTransaction.sortedIndices.forEach((s, o) => {\n\t\t\torderedProofs[s] = proofs[o];\n\t\t});\n\t\treturn orderedProofs;\n\t}\n\n\t/**\n\t * Send proofs of a given amount, by providing at least the required amount of proofs\n\t * @param amount amount to send\n\t * @param proofs array of proofs (accumulated amount of proofs must be >= than amount)\n\t * @param {SendOptions} [options] - Optional parameters for configuring the send operation\n\t * @returns {SendResponse}\n\t */\n\tasync send(amount: number, proofs: Array<Proof>, options?: SendOptions): Promise<SendResponse> {\n\t\tconst {\n\t\t\tproofsWeHave,\n\t\t\toffline,\n\t\t\tincludeFees,\n\t\t\tincludeDleq,\n\t\t\tkeysetId,\n\t\t\toutputAmounts,\n\t\t\tpubkey,\n\t\t\tprivkey,\n\t\t\toutputData\n\t\t} = options || {};\n\t\tif (includeDleq) {\n\t\t\tproofs = proofs.filter((p: Proof) => p.dleq != undefined);\n\t\t}\n\t\tif (sumProofs(proofs) < amount) {\n\t\t\tthrow new Error('Not enough funds available to send');\n\t\t}\n\t\tconst { keep: keepProofsOffline, send: sendProofOffline } = this.selectProofsToSend(\n\t\t\tproofs,\n\t\t\tamount,\n\t\t\toptions?.includeFees\n\t\t);\n\t\tconst expectedFee = includeFees ? this.getFeesForProofs(sendProofOffline) : 0;\n\t\tif (\n\t\t\t!offline &&\n\t\t\t(sumProofs(sendProofOffline) != amount + expectedFee || // if the exact amount cannot be selected\n\t\t\t\toutputAmounts ||\n\t\t\t\tpubkey ||\n\t\t\t\tprivkey ||\n\t\t\t\tkeysetId ||\n\t\t\t\toutputData) // these options require a swap\n\t\t) {\n\t\t\t// we need to swap\n\t\t\t// input selection, needs fees because of the swap\n\t\t\tconst { keep: keepProofsSelect, send: sendProofs } = this.selectProofsToSend(\n\t\t\t\tproofs,\n\t\t\t\tamount,\n\t\t\t\ttrue\n\t\t\t);\n\t\t\tproofsWeHave?.push(...keepProofsSelect);\n\n\t\t\tconst sendRes = await this.swap(amount, sendProofs, options);\n\t\t\tlet { keep, send } = sendRes;\n\t\t\tconst serialized = sendRes.serialized;\n\t\t\tkeep = keepProofsSelect.concat(keep);\n\n\t\t\tif (!includeDleq) {\n\t\t\t\tsend = stripDleq(send);\n\t\t\t}\n\n\t\t\treturn { keep, send, serialized };\n\t\t}\n\n\t\tif (sumProofs(sendProofOffline) < amount + expectedFee) {\n\t\t\tthrow new Error('Not enough funds available to send');\n\t\t}\n\n\t\tif (!includeDleq) {\n\t\t\treturn { keep: keepProofsOffline, send: stripDleq(sendProofOffline) };\n\t\t}\n\n\t\treturn { keep: keepProofsOffline, send: sendProofOffline };\n\t}\n\n\tselectProofsToSend(\n\t\tproofs: Array<Proof>,\n\t\tamountToSend: number,\n\t\tincludeFees?: boolean\n\t): SendResponse {\n\t\tconst sortedProofs = proofs.sort((a: Proof, b: Proof) => a.amount - b.amount);\n\t\tconst smallerProofs = sortedProofs\n\t\t\t.filter((p: Proof) => p.amount <= amountToSend)\n\t\t\t.sort((a: Proof, b: Proof) => b.amount - a.amount);\n\t\tconst biggerProofs = sortedProofs\n\t\t\t.filter((p: Proof) => p.amount > amountToSend)\n\t\t\t.sort((a: Proof, b: Proof) => a.amount - b.amount);\n\t\tconst nextBigger = biggerProofs[0];\n\t\tif (!smallerProofs.length && nextBigger) {\n\t\t\treturn {\n\t\t\t\tkeep: proofs.filter((p: Proof) => p.secret !== nextBigger.secret),\n\t\t\t\tsend: [nextBigger]\n\t\t\t};\n\t\t}\n\n\t\tif (!smallerProofs.length && !nextBigger) {\n\t\t\treturn { keep: proofs, send: [] };\n\t\t}\n\n\t\tlet remainder = amountToSend;\n\t\tlet selectedProofs = [smallerProofs[0]];\n\t\tconst returnedProofs = [];\n\t\tconst feePPK = includeFees ? this.getFeesForProofs(selectedProofs) : 0;\n\t\tremainder -= selectedProofs[0].amount - feePPK / 1000;\n\t\tif (remainder > 0) {\n\t\t\tconst { keep, send } = this.selectProofsToSend(\n\t\t\t\tsmallerProofs.slice(1),\n\t\t\t\tremainder,\n\t\t\t\tincludeFees\n\t\t\t);\n\t\t\tselectedProofs.push(...send);\n\t\t\treturnedProofs.push(...keep);\n\t\t}\n\n\t\tconst selectedFeePPK = includeFees ? this.getFeesForProofs(selectedProofs) : 0;\n\t\tif (sumProofs(selectedProofs) < amountToSend + selectedFeePPK && nextBigger) {\n\t\t\tselectedProofs = [nextBigger];\n\t\t}\n\n\t\treturn {\n\t\t\tkeep: proofs.filter((p: Proof) => !selectedProofs.includes(p)),\n\t\t\tsend: selectedProofs\n\t\t};\n\t}\n\n\t/**\n\t * calculates the fees based on inputs (proofs)\n\t * @param proofs input proofs to calculate fees for\n\t * @returns fee amount\n\t */\n\tgetFeesForProofs(proofs: Array<Proof>): number {\n\t\tif (!this._keysets.length) {\n\t\t\tthrow new Error('Could not calculate fees. No keysets found');\n\t\t}\n\t\tconst keysetIds = new Set(proofs.map((p: Proof) => p.id));\n\t\tkeysetIds.forEach((id: string) => {\n\t\t\tif (!this._keysets.find((k: MintKeyset) => k.id === id)) {\n\t\t\t\tthrow new Error(`Could not calculate fees. No keyset found with id: ${id}`);\n\t\t\t}\n\t\t});\n\n\t\tconst fees = Math.floor(\n\t\t\tMath.max(\n\t\t\t\t(proofs.reduce(\n\t\t\t\t\t(total: number, curr: Proof) =>\n\t\t\t\t\t\ttotal + (this._keysets.find((k: MintKeyset) => k.id === curr.id)?.input_fee_ppk || 0),\n\t\t\t\t\t0\n\t\t\t\t) +\n\t\t\t\t\t999) /\n\t\t\t\t\t1000,\n\t\t\t\t0\n\t\t\t)\n\t\t);\n\t\treturn fees;\n\t}\n\n\t/**\n\t * calculates the fees based on inputs for a given keyset\n\t * @param nInputs number of inputs\n\t * @param keysetId keysetId used to lookup `input_fee_ppk`\n\t * @returns fee amount\n\t */\n\tgetFeesForKeyset(nInputs: number, keysetId: string): number {\n\t\tconst fees = Math.floor(\n\t\t\tMath.max(\n\t\t\t\t(nInputs * (this._keysets.find((k: MintKeyset) => k.id === keysetId)?.input_fee_ppk || 0) +\n\t\t\t\t\t999) /\n\t\t\t\t\t1000,\n\t\t\t\t0\n\t\t\t)\n\t\t);\n\t\treturn fees;\n\t}\n\n\t/**\n\t * Splits and creates sendable tokens\n\t * if no amount is specified, the amount is implied by the cumulative amount of all proofs\n\t * if both amount and preference are set, but the preference cannot fulfill the amount, then we use the default split\n\t *  @param {SwapOptions} [options] - Optional parameters for configuring the swap operation\n\t * @returns promise of the change- and send-proofs\n\t */\n\tasync swap(amount: number, proofs: Array<Proof>, options?: SwapOptions): Promise<SendResponse> {\n\t\tlet { outputAmounts } = options || {};\n\t\tconst { includeFees, keysetId, counter, pubkey, privkey, proofsWeHave, outputData, p2pk } =\n\t\t\toptions || {};\n\t\tconst keyset = await this.getKeys(keysetId);\n\n\t\tconst proofsToSend = proofs;\n\t\tlet amountToSend = amount;\n\t\tconst amountAvailable = sumProofs(proofs);\n\t\tlet amountToKeep = amountAvailable - amountToSend - this.getFeesForProofs(proofsToSend);\n\t\t// send output selection\n\t\tlet sendAmounts = outputAmounts?.sendAmounts || splitAmount(amountToSend, keyset.keys);\n\n\t\t// include the fees to spend the the outputs of the swap\n\t\tif (includeFees) {\n\t\t\tlet outputFee = this.getFeesForKeyset(sendAmounts.length, keyset.id);\n\t\t\tlet sendAmountsFee = splitAmount(outputFee, keyset.keys);\n\t\t\twhile (\n\t\t\t\tthis.getFeesForKeyset(sendAmounts.concat(sendAmountsFee).length, keyset.id) > outputFee\n\t\t\t) {\n\t\t\t\toutputFee++;\n\t\t\t\tsendAmountsFee = splitAmount(outputFee, keyset.keys);\n\t\t\t}\n\t\t\tsendAmounts = sendAmounts.concat(sendAmountsFee);\n\t\t\tamountToSend += outputFee;\n\t\t\tamountToKeep -= outputFee;\n\t\t}\n\n\t\t// keep output selection\n\t\tlet keepAmounts;\n\t\tif (!outputAmounts?.keepAmounts && proofsWeHave) {\n\t\t\tkeepAmounts = getKeepAmounts(\n\t\t\t\tproofsWeHave,\n\t\t\t\tamountToKeep,\n\t\t\t\tkeyset.keys,\n\t\t\t\tthis._denominationTarget\n\t\t\t);\n\t\t} else if (outputAmounts) {\n\t\t\tif (outputAmounts.keepAmounts?.reduce((a: number, b: number) => a + b, 0) != amountToKeep) {\n\t\t\t\tthrow new Error('Keep amounts do not match amount to keep');\n\t\t\t}\n\t\t\tkeepAmounts = outputAmounts.keepAmounts;\n\t\t}\n\n\t\tif (amountToSend + this.getFeesForProofs(proofsToSend) > amountAvailable) {\n\t\t\tconsole.error(\n\t\t\t\t`Not enough funds available (${amountAvailable}) for swap amountToSend: ${amountToSend} + fee: ${this.getFeesForProofs(\n\t\t\t\t\tproofsToSend\n\t\t\t\t)} | length: ${proofsToSend.length}`\n\t\t\t);\n\t\t\tthrow new Error(`Not enough funds available for swap`);\n\t\t}\n\n\t\tif (amountToSend + this.getFeesForProofs(proofsToSend) + amountToKeep != amountAvailable) {\n\t\t\tthrow new Error('Amounts do not match for swap');\n\t\t}\n\n\t\toutputAmounts = {\n\t\t\tkeepAmounts: keepAmounts,\n\t\t\tsendAmounts: sendAmounts\n\t\t};\n\n\t\tconst keepOutputData = outputData?.keep || this._keepFactory;\n\t\tconst sendOutputData = outputData?.send;\n\n\t\tconst swapTransaction = this.createSwapPayload(\n\t\t\tamountToSend,\n\t\t\tproofsToSend,\n\t\t\tkeyset,\n\t\t\toutputAmounts,\n\t\t\tcounter,\n\t\t\tpubkey,\n\t\t\tprivkey,\n\t\t\t{ keep: keepOutputData, send: sendOutputData },\n\t\t\tp2pk\n\t\t);\n\t\tconst { signatures } = await this.mint.swap(swapTransaction.payload);\n\t\tconst swapProofs = swapTransaction.outputData.map((d, i) => d.toProof(signatures[i], keyset));\n\t\tconst splitProofsToKeep: Array<Proof> = [];\n\t\tconst splitProofsToSend: Array<Proof> = [];\n\t\tconst reorderedKeepVector = Array(swapTransaction.keepVector.length);\n\t\tconst reorderedProofs = Array(swapProofs.length);\n\t\tswapTransaction.sortedIndices.forEach((s, i) => {\n\t\t\treorderedKeepVector[s] = swapTransaction.keepVector[i];\n\t\t\treorderedProofs[s] = swapProofs[i];\n\t\t});\n\t\treorderedProofs.forEach((p, i) => {\n\t\t\tif (reorderedKeepVector[i]) {\n\t\t\t\tsplitProofsToKeep.push(p);\n\t\t\t} else {\n\t\t\t\tsplitProofsToSend.push(p);\n\t\t\t}\n\t\t});\n\t\treturn {\n\t\t\tkeep: splitProofsToKeep,\n\t\t\tsend: splitProofsToSend\n\t\t};\n\t}\n\n\t/**\n\t * Restores batches of deterministic proofs until no more signatures are returned from the mint\n\t * @param [gapLimit=300] the amount of empty counters that should be returned before restoring ends (defaults to 300)\n\t * @param [batchSize=100] the amount of proofs that should be restored at a time (defaults to 100)\n\t * @param [counter=0] the counter that should be used as a starting point (defaults to 0)\n\t * @param [keysetId] which keysetId to use for the restoration. If none is passed the instance's default one will be used\n\t */\n\tasync batchRestore(\n\t\tgapLimit = 300,\n\t\tbatchSize = 100,\n\t\tcounter = 0,\n\t\tkeysetId?: string\n\t): Promise<{ proofs: Array<Proof>; lastCounterWithSignature?: number }> {\n\t\tconst requiredEmptyBatches = Math.ceil(gapLimit / batchSize);\n\t\tconst restoredProofs: Array<Proof> = [];\n\n\t\tlet lastCounterWithSignature: undefined | number;\n\t\tlet emptyBatchesFound = 0;\n\n\t\twhile (emptyBatchesFound < requiredEmptyBatches) {\n\t\t\tconst restoreRes = await this.restore(counter, batchSize, { keysetId });\n\t\t\tif (restoreRes.proofs.length > 0) {\n\t\t\t\temptyBatchesFound = 0;\n\t\t\t\trestoredProofs.push(...restoreRes.proofs);\n\t\t\t\tlastCounterWithSignature = restoreRes.lastCounterWithSignature;\n\t\t\t} else {\n\t\t\t\temptyBatchesFound++;\n\t\t\t}\n\t\t\tcounter += batchSize;\n\t\t}\n\t\treturn { proofs: restoredProofs, lastCounterWithSignature };\n\t}\n\n\t/**\n\t * Regenerates\n\t * @param start set starting point for count (first cycle for each keyset should usually be 0)\n\t * @param count set number of blinded messages that should be generated\n\t * @param options.keysetId set a custom keysetId to restore from. keysetIds can be loaded with `CashuMint.getKeySets()`\n\t */\n\tasync restore(\n\t\tstart: number,\n\t\tcount: number,\n\t\toptions?: RestoreOptions\n\t): Promise<{ proofs: Array<Proof>; lastCounterWithSignature?: number }> {\n\t\tconst { keysetId } = options || {};\n\t\tconst keys = await this.getKeys(keysetId);\n\t\tif (!this._seed) {\n\t\t\tthrow new Error('CashuWallet must be initialized with a seed to use restore');\n\t\t}\n\t\t// create blank amounts for unknown restore amounts\n\t\tconst amounts = Array(count).fill(1);\n\t\tconst outputData = OutputData.createDeterministicData(\n\t\t\tamounts.length,\n\t\t\tthis._seed,\n\t\t\tstart,\n\t\t\tkeys,\n\t\t\tamounts\n\t\t);\n\n\t\tconst { outputs, signatures } = await this.mint.restore({\n\t\t\toutputs: outputData.map((d) => d.blindedMessage)\n\t\t});\n\n\t\tconst signatureMap: { [sig: string]: SerializedBlindedSignature } = {};\n\t\toutputs.forEach((o, i) => (signatureMap[o.B_] = signatures[i]));\n\n\t\tconst restoredProofs: Array<Proof> = [];\n\t\tlet lastCounterWithSignature: number | undefined;\n\n\t\tfor (let i = 0; i < outputData.length; i++) {\n\t\t\tconst matchingSig = signatureMap[outputData[i].blindedMessage.B_];\n\t\t\tif (matchingSig) {\n\t\t\t\tlastCounterWithSignature = start + i;\n\t\t\t\toutputData[i].blindedMessage.amount = matchingSig.amount;\n\t\t\t\trestoredProofs.push(outputData[i].toProof(matchingSig, keys));\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tproofs: restoredProofs,\n\t\t\tlastCounterWithSignature\n\t\t};\n\t}\n\n\t/**\n\t * Requests a mint quote form the mint. Response returns a Lightning payment request for the requested given amount and unit.\n\t * @param amount Amount requesting for mint.\n\t * @param description optional description for the mint quote\n\t * @param pubkey optional public key to lock the quote to\n\t * @returns the mint will return a mint quote with a Lightning invoice for minting tokens of the specified amount and unit\n\t */\n\tasync createMintQuote(amount: number, description?: string): Promise<MintQuoteResponse> {\n\t\tconst mintQuotePayload: MintQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\tamount: amount,\n\t\t\tdescription: description\n\t\t};\n\t\tconst res = await this.mint.createMintQuote(mintQuotePayload);\n\t\treturn { ...res, amount: res.amount || amount, unit: res.unit || this.unit };\n\t}\n\n\t/**\n\t * Requests a mint quote from the mint that is locked to a public key.\n\t * @param amount Amount requesting for mint.\n\t * @param pubkey public key to lock the quote to\n\t * @param description optional description for the mint quote\n\t * @returns the mint will return a mint quote with a Lightning invoice for minting tokens of the specified amount and unit.\n\t * The quote will be locked to the specified `pubkey`.\n\t */\n\tasync createLockedMintQuote(\n\t\tamount: number,\n\t\tpubkey: string,\n\t\tdescription?: string\n\t): Promise<LockedMintQuoteResponse> {\n\t\tconst { supported } = (await this.getMintInfo()).isSupported(20);\n\t\tif (!supported) {\n\t\t\tthrow new Error('Mint does not support NUT-20');\n\t\t}\n\t\tconst mintQuotePayload: MintQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\tamount: amount,\n\t\t\tdescription: description,\n\t\t\tpubkey: pubkey\n\t\t};\n\t\tconst res = await this.mint.createMintQuote(mintQuotePayload);\n\t\tif (typeof res.pubkey !== 'string') {\n\t\t\tthrow new Error('Mint returned unlocked mint quote');\n\t\t} else {\n\t\t\tconst pubkey = res.pubkey;\n\t\t\treturn { ...res, pubkey, amount: res.amount || amount, unit: res.unit || this.unit };\n\t\t}\n\t}\n\n\t/**\n\t * Gets an existing mint quote from the mint.\n\t * @param quote Quote ID\n\t * @returns the mint will create and return a Lightning invoice for the specified amount\n\t */\n\tasync checkMintQuote(quote: MintQuoteResponse): Promise<MintQuoteResponse>;\n\tasync checkMintQuote(quote: string): Promise<PartialMintQuoteResponse>;\n\tasync checkMintQuote(\n\t\tquote: string | MintQuoteResponse\n\t): Promise<MintQuoteResponse | PartialMintQuoteResponse> {\n\t\tconst quoteId = typeof quote === 'string' ? quote : quote.quote;\n\t\tconst baseRes = await this.mint.checkMintQuote(quoteId);\n\t\tif (typeof quote === 'string') {\n\t\t\treturn baseRes;\n\t\t}\n\t\treturn { ...baseRes, amount: baseRes.amount || quote.amount, unit: baseRes.unit || quote.unit };\n\t}\n\n\t/**\n\t * Mint proofs for a given mint quote\n\t * @param amount amount to request\n\t * @param {string} quote - ID of mint quote (when quote is a string)\n\t * @param {LockedMintQuote} quote - containing the quote ID and unlocking private key (when quote is a LockedMintQuote)\n\t * @param {MintProofOptions} [options] - Optional parameters for configuring the Mint Proof operation\n\t * @returns proofs\n\t */\n\tasync mintProofs(\n\t\tamount: number,\n\t\tquote: MintQuoteResponse,\n\t\toptions: MintProofOptions & { privateKey: string }\n\t): Promise<Array<Proof>>;\n\tasync mintProofs(\n\t\tamount: number,\n\t\tquote: string,\n\t\toptions?: MintProofOptions\n\t): Promise<Array<Proof>>;\n\tasync mintProofs(\n\t\tamount: number,\n\t\tquote: string | MintQuoteResponse,\n\t\toptions?: MintProofOptions & { privateKey?: string }\n\t): Promise<Array<Proof>> {\n\t\tlet { outputAmounts } = options || {};\n\t\tconst { counter, pubkey, p2pk, keysetId, proofsWeHave, outputData, privateKey } = options || {};\n\n\t\tconst keyset = await this.getKeys(keysetId);\n\t\tif (!outputAmounts && proofsWeHave) {\n\t\t\toutputAmounts = {\n\t\t\t\tkeepAmounts: getKeepAmounts(proofsWeHave, amount, keyset.keys, this._denominationTarget),\n\t\t\t\tsendAmounts: []\n\t\t\t};\n\t\t}\n\t\tlet newBlindingData: Array<OutputData> = [];\n\t\tif (outputData) {\n\t\t\tif (isOutputDataFactory(outputData)) {\n\t\t\t\tconst amounts = splitAmount(amount, keyset.keys, outputAmounts?.keepAmounts);\n\t\t\t\tfor (let i = 0; i < amounts.length; i++) {\n\t\t\t\t\tnewBlindingData.push(outputData(amounts[i], keyset));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnewBlindingData = outputData;\n\t\t\t}\n\t\t} else if (this._keepFactory) {\n\t\t\tconst amounts = splitAmount(amount, keyset.keys, outputAmounts?.keepAmounts);\n\t\t\tfor (let i = 0; i < amounts.length; i++) {\n\t\t\t\tnewBlindingData.push(this._keepFactory(amounts[i], keyset));\n\t\t\t}\n\t\t} else {\n\t\t\tnewBlindingData = this.createOutputData(\n\t\t\t\tamount,\n\t\t\t\tkeyset,\n\t\t\t\tcounter,\n\t\t\t\tpubkey,\n\t\t\t\toutputAmounts?.keepAmounts,\n\t\t\t\tp2pk\n\t\t\t);\n\t\t}\n\t\tlet mintPayload: MintPayload;\n\t\tif (typeof quote !== 'string') {\n\t\t\tif (!privateKey) {\n\t\t\t\tthrow new Error('Can not sign locked quote without private key');\n\t\t\t}\n\t\t\tconst blindedMessages = newBlindingData.map((d) => d.blindedMessage);\n\t\t\tconst mintQuoteSignature = signMintQuote(privateKey, quote.quote, blindedMessages);\n\t\t\tmintPayload = {\n\t\t\t\toutputs: blindedMessages,\n\t\t\t\tquote: quote.quote,\n\t\t\t\tsignature: mintQuoteSignature\n\t\t\t};\n\t\t} else {\n\t\t\tmintPayload = {\n\t\t\t\toutputs: newBlindingData.map((d) => d.blindedMessage),\n\t\t\t\tquote: quote\n\t\t\t};\n\t\t}\n\t\tconst { signatures } = await this.mint.mint(mintPayload);\n\t\treturn newBlindingData.map((d, i) => d.toProof(signatures[i], keyset));\n\t}\n\n\t/**\n\t * Requests a melt quote from the mint. Response returns amount and fees for a given unit in order to pay a Lightning invoice.\n\t * @param invoice LN invoice that needs to get a fee estimate\n\t * @returns the mint will create and return a melt quote for the invoice with an amount and fee reserve\n\t */\n\tasync createMeltQuote(invoice: string): Promise<MeltQuoteResponse> {\n\t\tconst meltQuotePayload: MeltQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\trequest: invoice\n\t\t};\n\t\tconst meltQuote = await this.mint.createMeltQuote(meltQuotePayload);\n\t\treturn {\n\t\t\t...meltQuote,\n\t\t\tunit: meltQuote.unit || this.unit,\n\t\t\trequest: meltQuote.request || invoice\n\t\t};\n\t}\n\n\t/**\n\t * Requests a multi path melt quote from the mint.\n\t * @param invoice LN invoice that needs to get a fee estimate\n\t * @param partialAmount the partial amount of the invoice's total to be paid by this instance\n\t * @returns the mint will create and return a melt quote for the invoice with an amount and fee reserve\n\t */\n\tasync createMultiPathMeltQuote(\n\t\tinvoice: string,\n\t\tmillisatPartialAmount: number\n\t): Promise<MeltQuoteResponse> {\n\t\tconst { supported, params } = (await this.lazyGetMintInfo()).isSupported(15);\n\t\tif (!supported) {\n\t\t\tthrow new Error('Mint does not support NUT-15');\n\t\t}\n\t\tif (!params?.some((p) => p.method === 'bolt11' && p.unit === this.unit)) {\n\t\t\tthrow new Error(`Mint does not support MPP for bolt11 and ${this.unit}`);\n\t\t}\n\t\tconst mppOption: MPPOption = {\n\t\t\tamount: millisatPartialAmount\n\t\t};\n\t\tconst meltOptions: MeltQuoteOptions = {\n\t\t\tmpp: mppOption\n\t\t};\n\t\tconst meltQuotePayload: MeltQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\trequest: invoice,\n\t\t\toptions: meltOptions\n\t\t};\n\t\tconst meltQuote = await this.mint.createMeltQuote(meltQuotePayload);\n\t\treturn { ...meltQuote, request: invoice, unit: this._unit };\n\t}\n\n\t/**\n\t * Return an existing melt quote from the mint.\n\t * @param quote ID of the melt quote\n\t * @returns the mint will return an existing melt quote\n\t */\n\tasync checkMeltQuote(quote: string): Promise<PartialMeltQuoteResponse>;\n\tasync checkMeltQuote(quote: MeltQuoteResponse): Promise<MeltQuoteResponse>;\n\tasync checkMeltQuote(\n\t\tquote: string | MeltQuoteResponse\n\t): Promise<MeltQuoteResponse | PartialMeltQuoteResponse> {\n\t\tconst quoteId = typeof quote === 'string' ? quote : quote.quote;\n\t\tconst meltQuote = await this.mint.checkMeltQuote(quoteId);\n\t\tif (typeof quote === 'string') {\n\t\t\treturn meltQuote;\n\t\t}\n\t\treturn { ...meltQuote, request: quote.request, unit: quote.unit };\n\t}\n\n\t/**\n\t * Melt proofs for a melt quote. proofsToSend must be at least amount+fee_reserve form the melt quote. This function does not perform coin selection!.\n\t * Returns melt quote and change proofs\n\t * @param meltQuote ID of the melt quote\n\t * @param proofsToSend proofs to melt\n\t * @param {MeltProofOptions} [options] - Optional parameters for configuring the Melting Proof operation\n\t * @returns\n\t */\n\tasync meltProofs(\n\t\tmeltQuote: MeltQuoteResponse,\n\t\tproofsToSend: Array<Proof>,\n\t\toptions?: MeltProofOptions\n\t): Promise<MeltProofsResponse> {\n\t\tconst { keysetId, counter, privkey } = options || {};\n\t\tconst keys = await this.getKeys(keysetId);\n\t\tconst outputData = this.createBlankOutputs(\n\t\t\tsumProofs(proofsToSend) - meltQuote.amount,\n\t\t\tkeys,\n\t\t\tcounter,\n\t\t\tthis._keepFactory\n\t\t);\n\t\tif (privkey != undefined) {\n\t\t\tproofsToSend = getSignedProofs(\n\t\t\t\tproofsToSend.map((p: Proof) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tamount: p.amount,\n\t\t\t\t\t\tC: pointFromHex(p.C),\n\t\t\t\t\t\tid: p.id,\n\t\t\t\t\t\tsecret: new TextEncoder().encode(p.secret)\n\t\t\t\t\t};\n\t\t\t\t}),\n\t\t\t\tprivkey\n\t\t\t).map((p: NUT11Proof) => serializeProof(p));\n\t\t}\n\n\t\tproofsToSend = stripDleq(proofsToSend);\n\n\t\tconst meltPayload: MeltPayload = {\n\t\t\tquote: meltQuote.quote,\n\t\t\tinputs: proofsToSend,\n\t\t\toutputs: outputData.map((d) => d.blindedMessage)\n\t\t};\n\t\tconst meltResponse = await this.mint.melt(meltPayload);\n\t\treturn {\n\t\t\tquote: { ...meltResponse, unit: meltQuote.unit, request: meltQuote.request },\n\t\t\tchange: meltResponse.change?.map((s, i) => outputData[i].toProof(s, keys)) ?? []\n\t\t};\n\t}\n\n\t/**\n\t * Creates a split payload\n\t * @param amount amount to send\n\t * @param proofsToSend proofs to split*\n\t * @param outputAmounts? optionally specify the output's amounts to keep and to send.\n\t * @param counter? optionally set counter to derive secret deterministically. CashuWallet class must be initialized with seed phrase to take effect\n\t * @param pubkey? optionally locks ecash to pubkey. Will not be deterministic, even if counter is set!\n\t * @param privkey? will create a signature on the @param proofsToSend secrets if set\n\t * @returns\n\t */\n\tprivate createSwapPayload(\n\t\tamount: number,\n\t\tproofsToSend: Array<Proof>,\n\t\tkeyset: MintKeys,\n\t\toutputAmounts?: OutputAmounts,\n\t\tcounter?: number,\n\t\tpubkey?: string,\n\t\tprivkey?: string,\n\t\tcustomOutputData?: {\n\t\t\tkeep?: Array<OutputDataLike> | OutputDataFactory;\n\t\t\tsend?: Array<OutputDataLike> | OutputDataFactory;\n\t\t},\n\t\tp2pk?: { pubkey: string; locktime?: number; refundKeys?: Array<string> }\n\t): SwapTransaction {\n\t\tconst totalAmount = proofsToSend.reduce((total: number, curr: Proof) => total + curr.amount, 0);\n\t\tif (outputAmounts && outputAmounts.sendAmounts && !outputAmounts.keepAmounts) {\n\t\t\toutputAmounts.keepAmounts = splitAmount(\n\t\t\t\ttotalAmount - amount - this.getFeesForProofs(proofsToSend),\n\t\t\t\tkeyset.keys\n\t\t\t);\n\t\t}\n\t\tconst keepAmount = totalAmount - amount - this.getFeesForProofs(proofsToSend);\n\t\tlet keepOutputData: Array<OutputDataLike> = [];\n\t\tlet sendOutputData: Array<OutputDataLike> = [];\n\n\t\tif (customOutputData?.keep) {\n\t\t\tif (isOutputDataFactory(customOutputData.keep)) {\n\t\t\t\tconst factory = customOutputData.keep;\n\t\t\t\tconst amounts = splitAmount(keepAmount, keyset.keys);\n\t\t\t\tamounts.forEach((a) => {\n\t\t\t\t\tkeepOutputData.push(factory(a, keyset));\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tkeepOutputData = customOutputData.keep;\n\t\t\t}\n\t\t} else {\n\t\t\tkeepOutputData = this.createOutputData(\n\t\t\t\tkeepAmount,\n\t\t\t\tkeyset,\n\t\t\t\tcounter,\n\t\t\t\tundefined,\n\t\t\t\toutputAmounts?.keepAmounts,\n\t\t\t\tundefined,\n\t\t\t\tthis._keepFactory\n\t\t\t);\n\t\t}\n\n\t\tif (customOutputData?.send) {\n\t\t\tif (isOutputDataFactory(customOutputData.send)) {\n\t\t\t\tconst factory = customOutputData.send;\n\t\t\t\tconst amounts = splitAmount(amount, keyset.keys);\n\t\t\t\tamounts.forEach((a) => {\n\t\t\t\t\tsendOutputData.push(factory(a, keyset));\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tsendOutputData = customOutputData.send;\n\t\t\t}\n\t\t} else {\n\t\t\tsendOutputData = this.createOutputData(\n\t\t\t\tamount,\n\t\t\t\tkeyset,\n\t\t\t\tcounter ? counter + keepOutputData.length : undefined,\n\t\t\t\tpubkey,\n\t\t\t\toutputAmounts?.sendAmounts,\n\t\t\t\tp2pk\n\t\t\t);\n\t\t}\n\n\t\tif (privkey) {\n\t\t\tproofsToSend = getSignedProofs(\n\t\t\t\tproofsToSend.map((p: Proof) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tamount: p.amount,\n\t\t\t\t\t\tC: pointFromHex(p.C),\n\t\t\t\t\t\tid: p.id,\n\t\t\t\t\t\tsecret: new TextEncoder().encode(p.secret)\n\t\t\t\t\t};\n\t\t\t\t}),\n\t\t\t\tprivkey\n\t\t\t).map((p: NUT11Proof) => serializeProof(p));\n\t\t}\n\n\t\tproofsToSend = stripDleq(proofsToSend);\n\n\t\tconst mergedBlindingData = [...keepOutputData, ...sendOutputData];\n\t\tconst indices = mergedBlindingData\n\t\t\t.map((_, i) => i)\n\t\t\t.sort(\n\t\t\t\t(a, b) =>\n\t\t\t\t\tmergedBlindingData[a].blindedMessage.amount - mergedBlindingData[b].blindedMessage.amount\n\t\t\t);\n\t\tconst keepVector = [\n\t\t\t...Array(keepOutputData.length).fill(true),\n\t\t\t...Array(sendOutputData.length).fill(false)\n\t\t];\n\n\t\tconst sortedOutputData = indices.map((i) => mergedBlindingData[i]);\n\t\tconst sortedKeepVector = indices.map((i) => keepVector[i]);\n\n\t\treturn {\n\t\t\tpayload: {\n\t\t\t\tinputs: proofsToSend,\n\t\t\t\toutputs: sortedOutputData.map((d) => d.blindedMessage)\n\t\t\t},\n\t\t\toutputData: sortedOutputData,\n\t\t\tkeepVector: sortedKeepVector,\n\t\t\tsortedIndices: indices\n\t\t};\n\t}\n\n\t/**\n\t * Get an array of the states of proofs from the mint (as an array of CheckStateEnum's)\n\t * @param proofs (only the `secret` field is required)\n\t * @returns\n\t */\n\tasync checkProofsStates(proofs: Array<Proof>): Promise<Array<ProofState>> {\n\t\tconst enc = new TextEncoder();\n\t\tconst Ys = proofs.map((p: Proof) => hashToCurve(enc.encode(p.secret)).toHex(true));\n\t\t// TODO: Replace this with a value from the info endpoint of the mint eventually\n\t\tconst BATCH_SIZE = 100;\n\t\tconst states: Array<ProofState> = [];\n\t\tfor (let i = 0; i < Ys.length; i += BATCH_SIZE) {\n\t\t\tconst YsSlice = Ys.slice(i, i + BATCH_SIZE);\n\t\t\tconst { states: batchStates } = await this.mint.check({\n\t\t\t\tYs: YsSlice\n\t\t\t});\n\t\t\tconst stateMap: { [y: string]: ProofState } = {};\n\t\t\tbatchStates.forEach((s) => {\n\t\t\t\tstateMap[s.Y] = s;\n\t\t\t});\n\t\t\tfor (let j = 0; j < YsSlice.length; j++) {\n\t\t\t\tconst state = stateMap[YsSlice[j]];\n\t\t\t\tif (!state) {\n\t\t\t\t\tthrow new Error('Could not find state for proof with Y: ' + YsSlice[j]);\n\t\t\t\t}\n\t\t\t\tstates.push(state);\n\t\t\t}\n\t\t}\n\t\treturn states;\n\t}\n\n\t/**\n\t * Register a callback to be called whenever a mint quote's state changes\n\t * @param quoteIds List of mint quote IDs that should be subscribed to\n\t * @param callback Callback function that will be called whenever a mint quote state changes\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync onMintQuoteUpdates(\n\t\tquoteIds: Array<string>,\n\t\tcallback: (payload: MintQuoteResponse) => void,\n\t\terrorCallback: (e: Error) => void\n\t): Promise<SubscriptionCanceller> {\n\t\tawait this.mint.connectWebSocket();\n\t\tif (!this.mint.webSocketConnection) {\n\t\t\tthrow new Error('failed to establish WebSocket connection.');\n\t\t}\n\t\tconst subId = this.mint.webSocketConnection.createSubscription(\n\t\t\t{ kind: 'bolt11_mint_quote', filters: quoteIds },\n\t\t\tcallback,\n\t\t\terrorCallback\n\t\t);\n\t\treturn () => {\n\t\t\tthis.mint.webSocketConnection?.cancelSubscription(subId, callback);\n\t\t};\n\t}\n\n\t/**\n\t * Register a callback to be called whenever a melt quote's state changes\n\t * @param quoteIds List of melt quote IDs that should be subscribed to\n\t * @param callback Callback function that will be called whenever a melt quote state changes\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync onMeltQuotePaid(\n\t\tquoteId: string,\n\t\tcallback: (payload: MeltQuoteResponse) => void,\n\t\terrorCallback: (e: Error) => void\n\t): Promise<SubscriptionCanceller> {\n\t\treturn this.onMeltQuoteUpdates(\n\t\t\t[quoteId],\n\t\t\t(p) => {\n\t\t\t\tif (p.state === MeltQuoteState.PAID) {\n\t\t\t\t\tcallback(p);\n\t\t\t\t}\n\t\t\t},\n\t\t\terrorCallback\n\t\t);\n\t}\n\n\t/**\n\t * Register a callback to be called when a single mint quote gets paid\n\t * @param quoteId Mint quote id that should be subscribed to\n\t * @param callback Callback function that will be called when this mint quote gets paid\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync onMintQuotePaid(\n\t\tquoteId: string,\n\t\tcallback: (payload: MintQuoteResponse) => void,\n\t\terrorCallback: (e: Error) => void\n\t): Promise<SubscriptionCanceller> {\n\t\treturn this.onMintQuoteUpdates(\n\t\t\t[quoteId],\n\t\t\t(p) => {\n\t\t\t\tif (p.state === MintQuoteState.PAID) {\n\t\t\t\t\tcallback(p);\n\t\t\t\t}\n\t\t\t},\n\t\t\terrorCallback\n\t\t);\n\t}\n\n\t/**\n\t * Register a callback to be called when a single melt quote gets paid\n\t * @param quoteId Melt quote id that should be subscribed to\n\t * @param callback Callback function that will be called when this melt quote gets paid\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync onMeltQuoteUpdates(\n\t\tquoteIds: Array<string>,\n\t\tcallback: (payload: MeltQuoteResponse) => void,\n\t\terrorCallback: (e: Error) => void\n\t): Promise<SubscriptionCanceller> {\n\t\tawait this.mint.connectWebSocket();\n\t\tif (!this.mint.webSocketConnection) {\n\t\t\tthrow new Error('failed to establish WebSocket connection.');\n\t\t}\n\t\tconst subId = this.mint.webSocketConnection.createSubscription(\n\t\t\t{ kind: 'bolt11_melt_quote', filters: quoteIds },\n\t\t\tcallback,\n\t\t\terrorCallback\n\t\t);\n\t\treturn () => {\n\t\t\tthis.mint.webSocketConnection?.cancelSubscription(subId, callback);\n\t\t};\n\t}\n\n\t/**\n\t * Register a callback to be called whenever a subscribed proof state changes\n\t * @param proofs List of proofs that should be subscribed to\n\t * @param callback Callback function that will be called whenever a proof's state changes\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync onProofStateUpdates(\n\t\tproofs: Array<Proof>,\n\t\tcallback: (payload: ProofState & { proof: Proof }) => void,\n\t\terrorCallback: (e: Error) => void\n\t): Promise<SubscriptionCanceller> {\n\t\tawait this.mint.connectWebSocket();\n\t\tif (!this.mint.webSocketConnection) {\n\t\t\tthrow new Error('failed to establish WebSocket connection.');\n\t\t}\n\t\tconst enc = new TextEncoder();\n\t\tconst proofMap: { [y: string]: Proof } = {};\n\t\tfor (let i = 0; i < proofs.length; i++) {\n\t\t\tconst y = hashToCurve(enc.encode(proofs[i].secret)).toHex(true);\n\t\t\tproofMap[y] = proofs[i];\n\t\t}\n\t\tconst ys = Object.keys(proofMap);\n\t\tconst subId = this.mint.webSocketConnection.createSubscription(\n\t\t\t{ kind: 'proof_state', filters: ys },\n\t\t\t(p: ProofState) => {\n\t\t\t\tcallback({ ...p, proof: proofMap[p.Y] });\n\t\t\t},\n\t\t\terrorCallback\n\t\t);\n\t\treturn () => {\n\t\t\tthis.mint.webSocketConnection?.cancelSubscription(subId, callback);\n\t\t};\n\t}\n\n\t/**\n\t * Creates blinded messages for a according to @param amounts\n\t * @param amount array of amounts to create blinded messages for\n\t * @param counter? optionally set counter to derive secret deterministically. CashuWallet class must be initialized with seed phrase to take effect\n\t * @param keyksetId? override the keysetId derived from the current mintKeys with a custom one. This should be a keyset that was fetched from the `/keysets` endpoint\n\t * @param pubkey? optionally locks ecash to pubkey. Will not be deterministic, even if counter is set!\n\t * @returns blinded messages, secrets, rs, and amounts\n\t */\n\tprivate createOutputData(\n\t\tamount: number,\n\t\tkeyset: MintKeys,\n\t\tcounter?: number,\n\t\tpubkey?: string,\n\t\toutputAmounts?: Array<number>,\n\t\tp2pk?: { pubkey: string; locktime?: number; refundKeys?: Array<string> },\n\t\tfactory?: OutputDataFactory\n\t): Array<OutputDataLike> {\n\t\tlet outputData: Array<OutputDataLike>;\n\t\tif (pubkey) {\n\t\t\toutputData = OutputData.createP2PKData({ pubkey }, amount, keyset, outputAmounts);\n\t\t} else if (counter || counter === 0) {\n\t\t\tif (!this._seed) {\n\t\t\t\tthrow new Error('cannot create deterministic messages without seed');\n\t\t\t}\n\t\t\toutputData = OutputData.createDeterministicData(\n\t\t\t\tamount,\n\t\t\t\tthis._seed,\n\t\t\t\tcounter,\n\t\t\t\tkeyset,\n\t\t\t\toutputAmounts\n\t\t\t);\n\t\t} else if (p2pk) {\n\t\t\toutputData = OutputData.createP2PKData(p2pk, amount, keyset, outputAmounts);\n\t\t} else if (factory) {\n\t\t\tconst amounts = splitAmount(amount, keyset.keys);\n\t\t\toutputData = amounts.map((a) => factory(a, keyset));\n\t\t} else {\n\t\t\toutputData = OutputData.createRandomData(amount, keyset, outputAmounts);\n\t\t}\n\t\treturn outputData;\n\t}\n\n\t/**\n\t * Creates NUT-08 blank outputs (fee returns) for a given fee reserve\n\t * See: https://github.com/cashubtc/nuts/blob/main/08.md\n\t * @param amount amount to cover with blank outputs\n\t * @param keysetId mint keysetId\n\t * @param counter? optionally set counter to derive secret deterministically. CashuWallet class must be initialized with seed phrase to take effect\n\t * @returns blinded messages, secrets, and rs\n\t */\n\tprivate createBlankOutputs(\n\t\tamount: number,\n\t\tkeyset: MintKeys,\n\t\tcounter?: number,\n\t\tfactory?: OutputDataFactory\n\t): Array<OutputDataLike> {\n\t\tlet count = Math.ceil(Math.log2(amount)) || 1;\n\t\t//Prevent count from being -Infinity\n\t\tif (count < 0) {\n\t\t\tcount = 0;\n\t\t}\n\t\tconst amounts = count ? Array(count).fill(1) : [];\n\t\treturn this.createOutputData(\n\t\t\tamounts.length,\n\t\t\tkeyset,\n\t\t\tcounter,\n\t\t\tundefined,\n\t\t\tamounts,\n\t\t\tundefined,\n\t\t\tfactory\n\t\t);\n\t}\n}\n\nexport { CashuWallet };\n","import {\n\tBlindAuthMintPayload,\n\tBlindAuthMintResponse,\n\tMintActiveKeys,\n\tMintAllKeysets\n} from '../model/types';\nimport request from '../request';\nimport { isObj, joinUrls, sanitizeUrl } from '../utils';\n\n/**\n * Class represents Cashu Auth Mint API. This class contains Lower level functions that are implemented by CashuAuthWallet.\n */\nclass CashuAuthMint {\n\t/**\n\t * @param _mintUrl requires mint URL to create this object\n\t * @param _customRequest if passed, use custom request implementation for network communication with the mint\n\t */\n\tconstructor(private _mintUrl: string, private _customRequest?: typeof request) {\n\t\tthis._mintUrl = sanitizeUrl(_mintUrl);\n\t\tthis._customRequest = _customRequest;\n\t}\n\n\tget mintUrl() {\n\t\treturn this._mintUrl;\n\t}\n\n\t/**\n\t * Mints new Blinded Authentication tokens by requesting blind signatures on the provided outputs.\n\t * @param mintUrl\n\t * @param mintPayload Payload containing the outputs to get blind signatures on\n\t * @param clearAuthToken A NUT-21 clear auth token\n\t * @param customRequest\n\t * @returns serialized blinded signatures\n\t */\n\tpublic static async mint(\n\t\tmintUrl: string,\n\t\tmintPayload: BlindAuthMintPayload,\n\t\tclearAuthToken: string,\n\t\tcustomRequest?: typeof request\n\t) {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers = {\n\t\t\t'Clear-auth': `${clearAuthToken}`\n\t\t};\n\t\tconst data = await requestInstance<BlindAuthMintResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/auth/blind/mint'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: mintPayload,\n\t\t\theaders\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.signatures)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Mints new Blinded Authentication tokens by requesting blind signatures on the provided outputs.\n\t * @param mintPayload Payload containing the outputs to get blind signatures on\n\t * @param clearAuthToken A NUT-21 clear auth token\n\t * @returns serialized blinded signatures\n\t */\n\tasync mint(mintPayload: BlindAuthMintPayload, clearAuthToken: string) {\n\t\treturn CashuAuthMint.mint(this._mintUrl, mintPayload, clearAuthToken, this._customRequest);\n\t}\n\n\t/**\n\t * Get the mints public NUT-22 keys\n\t * @param mintUrl\n\t * @param keysetId optional param to get the keys for a specific keyset. If not specified, the keys from all active keysets are fetched\n\t * @param customRequest\n\t * @returns\n\t */\n\tpublic static async getKeys(\n\t\tmintUrl: string,\n\t\tkeysetId?: string,\n\t\tcustomRequest?: typeof request\n\t): Promise<MintActiveKeys> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst data = await requestInstance<MintActiveKeys>({\n\t\t\tendpoint: keysetId\n\t\t\t\t? joinUrls(mintUrl, '/v1/auth/blind/keys', keysetId)\n\t\t\t\t: joinUrls(mintUrl, '/v1/auth/blind/keys')\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data.keysets)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Get the mints public NUT-22 keys\n\t * @param keysetId optional param to get the keys for a specific keyset. If not specified, the keys from all active keysets are fetched\n\t * @returns the mints public keys\n\t */\n\tasync getKeys(keysetId?: string, mintUrl?: string): Promise<MintActiveKeys> {\n\t\tconst allKeys = await CashuAuthMint.getKeys(\n\t\t\tmintUrl || this._mintUrl,\n\t\t\tkeysetId,\n\t\t\tthis._customRequest\n\t\t);\n\t\treturn allKeys;\n\t}\n\t/**\n\t * Get the mints NUT-22 keysets in no specific order\n\t * @param mintUrl\n\t * @param customRequest\n\t * @returns all the mints past and current keysets.\n\t */\n\tpublic static async getKeySets(\n\t\tmintUrl: string,\n\t\tcustomRequest?: typeof request\n\t): Promise<MintAllKeysets> {\n\t\tconst requestInstance = customRequest || request;\n\t\treturn requestInstance<MintAllKeysets>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/auth/blind/keysets')\n\t\t});\n\t}\n\n\t/**\n\t * Get the mints NUT-22 keysets in no specific order\n\t * @returns all the mints past and current keysets.\n\t */\n\tasync getKeySets(): Promise<MintAllKeysets> {\n\t\treturn CashuAuthMint.getKeySets(this._mintUrl, this._customRequest);\n\t}\n}\n\nexport { CashuAuthMint };\n","import { OutputData } from '../model/OutputData';\nimport { BlindAuthMintPayload, MintKeys, MintKeyset, Proof } from '../model/types';\nimport { hasValidDleq } from '../utils';\nimport { CashuAuthMint } from './CashuAuthMint';\n\n/**\n * Class that represents a Cashu NUT-22 wallet.\n */\nclass CashuAuthWallet {\n\tprivate _keys: Map<string, MintKeys> = new Map();\n\tprivate _keysetId: string | undefined;\n\tprivate _keysets: Array<MintKeyset> = [];\n\tprivate _unit = 'auth';\n\n\tmint: CashuAuthMint;\n\n\t/**\n\t * @param mint NUT-22 auth mint instance\n\t * @param options.keys public keys from the mint (will be fetched from mint if not provided)\n\t * @param options.keysets keysets from the mint (will be fetched from mint if not provided)\n\t */\n\tconstructor(\n\t\tmint: CashuAuthMint,\n\t\toptions?: {\n\t\t\tkeys?: Array<MintKeys> | MintKeys;\n\t\t\tkeysets?: Array<MintKeyset>;\n\t\t}\n\t) {\n\t\tthis.mint = mint;\n\t\tlet keys: Array<MintKeys> = [];\n\t\tif (options?.keys && !Array.isArray(options.keys)) {\n\t\t\tkeys = [options.keys];\n\t\t} else if (options?.keys && Array.isArray(options?.keys)) {\n\t\t\tkeys = options?.keys;\n\t\t}\n\t\tif (keys) keys.forEach((key: MintKeys) => this._keys.set(key.id, key));\n\t\tif (options?.keysets) this._keysets = options.keysets;\n\t}\n\n\tget keys(): Map<string, MintKeys> {\n\t\treturn this._keys;\n\t}\n\tget keysetId(): string {\n\t\tif (!this._keysetId) {\n\t\t\tthrow new Error('No keysetId set');\n\t\t}\n\t\treturn this._keysetId;\n\t}\n\tset keysetId(keysetId: string) {\n\t\tthis._keysetId = keysetId;\n\t}\n\tget keysets(): Array<MintKeyset> {\n\t\treturn this._keysets;\n\t}\n\n\t/**\n\t * Load mint information, keysets and keys. This function can be called if no keysets are passed in the constructor\n\t */\n\tasync loadMint() {\n\t\tawait this.getKeySets();\n\t\tawait this.getKeys();\n\t}\n\n\t/**\n\t * Choose a keyset to activate based on the lowest input fee\n\t *\n\t * Note: this function will filter out deprecated base64 keysets\n\t *\n\t * @param keysets keysets to choose from\n\t * @returns active keyset\n\t */\n\tgetActiveKeyset(keysets: Array<MintKeyset>): MintKeyset {\n\t\tlet activeKeysets = keysets.filter((k: MintKeyset) => k.active);\n\n\t\t// we only consider keyset IDs that start with \"00\"\n\t\tactiveKeysets = activeKeysets.filter((k: MintKeyset) => k.id.startsWith('00'));\n\n\t\tconst activeKeyset = activeKeysets.sort(\n\t\t\t(a: MintKeyset, b: MintKeyset) => (a.input_fee_ppk ?? 0) - (b.input_fee_ppk ?? 0)\n\t\t)[0];\n\t\tif (!activeKeyset) {\n\t\t\tthrow new Error('No active keyset found');\n\t\t}\n\t\treturn activeKeyset;\n\t}\n\n\t/**\n\t * Get keysets from the mint with the unit of the wallet\n\t * @returns keysets with wallet's unit\n\t */\n\tasync getKeySets(): Promise<Array<MintKeyset>> {\n\t\tconst allKeysets = await this.mint.getKeySets();\n\t\tconst unitKeysets = allKeysets.keysets.filter((k: MintKeyset) => k.unit === this._unit);\n\t\tthis._keysets = unitKeysets;\n\t\treturn this._keysets;\n\t}\n\n\t/**\n\t * Get all active keys from the mint and set the keyset with the lowest fees as the active wallet keyset.\n\t * @returns keyset\n\t */\n\tasync getAllKeys(): Promise<Array<MintKeys>> {\n\t\tconst keysets = await this.mint.getKeys();\n\t\tthis._keys = new Map(keysets.keysets.map((k: MintKeys) => [k.id, k]));\n\t\tthis.keysetId = this.getActiveKeyset(this._keysets).id;\n\t\treturn keysets.keysets;\n\t}\n\n\t/**\n\t * Get public keys from the mint. If keys were already fetched, it will return those.\n\t *\n\t * If `keysetId` is set, it will fetch and return that specific keyset.\n\t * Otherwise, we select an active keyset with the unit of the wallet.\n\t *\n\t * @param keysetId optional keysetId to get keys for\n\t * @param forceRefresh? if set to true, it will force refresh the keyset from the mint\n\t * @returns keyset\n\t */\n\tasync getKeys(keysetId?: string, forceRefresh?: boolean): Promise<MintKeys> {\n\t\tif (!(this._keysets.length > 0) || forceRefresh) {\n\t\t\tawait this.getKeySets();\n\t\t}\n\t\t// no keyset id is chosen, let's choose one\n\t\tif (!keysetId) {\n\t\t\tconst localKeyset = this.getActiveKeyset(this._keysets);\n\t\t\tkeysetId = localKeyset.id;\n\t\t}\n\t\t// make sure we have keyset for this id\n\t\tif (!this._keysets.find((k: MintKeyset) => k.id === keysetId)) {\n\t\t\tawait this.getKeySets();\n\t\t\tif (!this._keysets.find((k: MintKeyset) => k.id === keysetId)) {\n\t\t\t\tthrow new Error(`could not initialize keys. No keyset with id '${keysetId}' found`);\n\t\t\t}\n\t\t}\n\n\t\t// make sure we have keys for this id\n\t\tif (!this._keys.get(keysetId)) {\n\t\t\tconst keys = await this.mint.getKeys(keysetId);\n\t\t\tthis._keys.set(keysetId, keys.keysets[0]);\n\t\t}\n\n\t\t// set and return\n\t\tthis.keysetId = keysetId;\n\t\treturn this._keys.get(keysetId) as MintKeys;\n\t}\n\n\t/**\n\t * Mint proofs for a given mint quote\n\t * @param amount amount to request\n\t * @param clearAuthToken clearAuthToken to mint\n\t * @param options.keysetId? optionally set keysetId for blank outputs for returned change.\n\t * @returns proofs\n\t */\n\tasync mintProofs(\n\t\tamount: number,\n\t\tclearAuthToken: string,\n\t\toptions?: {\n\t\t\tkeysetId?: string;\n\t\t}\n\t): Promise<Array<Proof>> {\n\t\tconst keyset = await this.getKeys(options?.keysetId);\n\t\tconst outputData = OutputData.createRandomData(amount, keyset);\n\n\t\tconst mintPayload: BlindAuthMintPayload = {\n\t\t\toutputs: outputData.map((d) => d.blindedMessage)\n\t\t};\n\t\tconst { signatures } = await this.mint.mint(mintPayload, clearAuthToken);\n\t\tconst authProofs = outputData.map((d, i) => d.toProof(signatures[i], keyset));\n\t\tif (authProofs.some((p) => !hasValidDleq(p, keyset))) {\n\t\t\tthrow new Error('Mint returned auth proofs with invalid DLEQ');\n\t\t}\n\t\treturn authProofs;\n\t}\n}\n\nexport { CashuAuthWallet };\n","import { CashuAuthMint } from './CashuAuthMint';\nimport { CashuAuthWallet } from './CashuAuthWallet';\nimport { encodeJsonToBase64 } from '../base64';\nimport { Proof } from '../model/types';\n\n/**\n * Helper function to encode a cashu auth token authA\n * @param proof\n */\nexport function getEncodedAuthToken(proof: Proof): string {\n\tconst token = {\n\t\tid: proof.id,\n\t\tsecret: proof.secret,\n\t\tC: proof.C\n\t};\n\tconst base64Data = encodeJsonToBase64(token);\n\tconst prefix = 'auth';\n\tconst version = 'A';\n\treturn prefix + version + base64Data;\n}\n\nexport async function getBlindedAuthToken(amount: number, url: string, clearAuthToken: string) {\n\tconst authMint = new CashuAuthMint(url);\n\tconst authWallet = new CashuAuthWallet(authMint);\n\tconst authProofs = await authWallet.mintProofs(amount, clearAuthToken);\n\treturn authProofs.map((p) => getEncodedAuthToken(p));\n}\n\nexport { CashuAuthMint, CashuAuthWallet };\n"],"names":["bytesToNumber","bytes","hexToNumber","bytesToHex","hex","encodeBase64toUint8","base64String","Buffer","DOMAIN_SEPARATOR","hexToBytes","hashToCurve","secret","msgToHash","sha256","counter","maxIterations","i","counterBytes","hash","pointFromHex","hash_e","pubkeys","e_","p","secp256k1","getKeysetIdInt","keysetId","keysetIdInt","arraysEqual","arr1","arr2","verifyDLEQProof","dleq","B_","C_","A","sG","eA","sB_","eC_","R_1","R_2","verifyDLEQProof_reblind","C","Y","bG","encodeUint8toBase64Url","encodeJsonToBase64","jsonObj","jsonString","base64urlFromBase64","encodeBase64ToJson","base64urlToBase64","str","isResultKeyType","value","encodeCBOR","buffer","encodeItem","encodeUnsigned","encodeString","encodeArray","encodeByteString","encodeObject","length","utf8","item","keys","key","decodeCBOR","data","view","decodeItem","offset","initialByte","majorType","additionalInfo","decodeUnsigned","decodeSigned","decodeByteString","decodeString","decodeArray","decodeMap","decodeSimpleAndFloat","decodeLength","hi","lo","newOffset","array","currentOffset","result","map","keyResult","valueResult","decodeFloat16","uint16","exponent","fraction","sign","PaymentRequest","transport","id","amount","unit","mints","description","singleUse","nut10","rawRequest","t","type","rawPaymentRequest","transports","encodedRequest","encodedData","decoded","TOKEN_VERSION","TOKEN_PREFIX","splitAmount","keyset","split","order","totalSplitAmount","sumArray","amt","hasCorrespondingKey","getKeysetAmounts","q","a","b","getKeepAmounts","proofsWeHave","amountToKeep","targetCount","amountsWeWant","amountsWeHave","countWeHave","countWeWant","amountDiff","k","numberToHexPadded64","number","isValidHex","hasNonHexId","proof","getEncodedTokenV3","token","v3TokenObj","getEncodedToken","opts","getEncodedTokenV4","tokenTemplate","templateFromToken","prefix","version","base64Data","idMap","mint","tokenFromTemplate","template","proofs","decodedToken","getDecodedToken","handleTokens","encodedToken","parsedV3Token","entry","tokenObj","uInt8Token","tokenData","deriveKeysetId","pubkeysConcat","pubKey","prev","curr","mergeUInt8Arrays","a1","a2","mergedArray","isObj","v","joinUrls","parts","part","sanitizeUrl","url","sumProofs","acc","decodePaymentRequest","paymentRequest","MessageNode","message","node","MessageQueue","messageNode","newNode","stripDleq","newP","hasValidDleq","concatByteArrays","arrays","totalLength","c","byteArray","pointer","getEncodedTokenBinary","utf8Encoder","binaryTemplate","getDecodedTokenBinary","utfDecoder","binaryToken","arr","_WS","injectWebSocketImpl","ws","getWebSocketImpl","ConnectionManager","newConn","WSConnection","res","rej","err","e","method","params","subId","callback","errorCallback","fn","parsed","notification","cb","CheckStateEnum","MeltQuoteState","MintQuoteState","PaymentRequestTransportType","HttpResponseError","status","NetworkError","MintOperationError","code","detail","globalRequestOptions","setGlobalRequestOptions","options","_request","endpoint","requestBody","requestHeaders","body","headers","response","errorData","request","handleMeltQuoteResponseDeprecated","handleMintQuoteResponseDeprecated","handleMintInfoContactFieldDeprecated","contact","MintInfo","info","o","num","path","isProtectedEndpoint","mintMeltInfo","CashuMint","_mintUrl","_customRequest","authTokenGetter","mintUrl","customRequest","swapPayload","blindAuthToken","requestInstance","mintQuotePayload","quote","mintPayload","meltQuotePayload","meltPayload","checkPayload","restorePayload","wsSegment","parseSecret","signP2PKsecret","privateKey","msghash","schnorr","getSignedProofs","keypairs","pk","matchingKey","pair","getSignedProof","blindMessage","r","rG","unblindSignature","constructProofFromPromise","promise","serializeProof","constructMessage","blindedMessages","blindedMessage","msgbytes","signMintQuote","privkey","privkeyBytes","signature","BlindedMessage","STANDARD_DERIVATION_PATH","deriveSecret","seed","derive","deriveBlindingFactor","secretOrBlinding","hdkey","HDKey","derivationPath","derived","isOutputDataFactory","OutputData","blidingFactor","sig","blindSignature","p2pk","customSplit","newSecret","randomBytes","secretBytes","randomHex","secretBytesAsHex","utf8SecretBytes","deterministicR","DEFAULT_DENOMINATION_TARGET","DEFAULT_UNIT","CashuWallet","infoRes","keysets","activeKeysets","activeKeyset","unitKeysets","forceRefresh","requireDleq","outputAmounts","pubkey","outputData","newOutputData","swapTransaction","signatures","d","orderedProofs","s","offline","includeFees","includeDleq","keepProofsOffline","sendProofOffline","expectedFee","keepProofsSelect","sendProofs","sendRes","keep","send","serialized","amountToSend","sortedProofs","smallerProofs","nextBigger","remainder","selectedProofs","returnedProofs","feePPK","selectedFeePPK","total","nInputs","proofsToSend","amountAvailable","sendAmounts","outputFee","sendAmountsFee","keepAmounts","keepOutputData","sendOutputData","swapProofs","splitProofsToKeep","splitProofsToSend","reorderedKeepVector","reorderedProofs","gapLimit","batchSize","requiredEmptyBatches","restoredProofs","lastCounterWithSignature","emptyBatchesFound","restoreRes","start","count","amounts","outputs","signatureMap","matchingSig","supported","quoteId","baseRes","newBlindingData","mintQuoteSignature","invoice","meltQuote","millisatPartialAmount","meltOptions","meltResponse","customOutputData","totalAmount","keepAmount","factory","mergedBlindingData","indices","_","keepVector","sortedOutputData","sortedKeepVector","enc","Ys","BATCH_SIZE","states","YsSlice","batchStates","stateMap","j","state","quoteIds","proofMap","y","ys","CashuAuthMint","clearAuthToken","CashuAuthWallet","authProofs","getEncodedAuthToken","getBlindedAuthToken","authMint"],"mappings":"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"}